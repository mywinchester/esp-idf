#
# Please run the following command for opening a page with more information about this configuration file:
# idf.py docs -sp api-reference/kconfig.html
#
mainmenu "Espressif IoT Development Framework Configuration"

    orsource "./components/soc/$IDF_TARGET/include/soc/Kconfig.soc_caps.in"

    config IDF_CMAKE
        bool
        default "y"

    config IDF_ENV_FPGA
        bool
        option env="IDF_ENV_FPGA"
        help
            - 此选项仅供内部使用。
            - 启用此选项将帮助启用所有FPGA支持，以便在FPGA上运行ESP-IDF。这可以帮助重现一些只在FPGA条件下发生的问题，或者当您必须多次烧写一些efuses时。

    config IDF_ENV_BRINGUP
        bool
        help
            - 此选项仅在进行新芯片引导时使用。
            - 此选项将仅启用运行hello_world应用程序所需的必要硬件/软件设置。


    config IDF_CI_BUILD
        bool
        default y if "$(IDF_CI_BUILD)" = "y" || "$(IDF_CI_BUILD)" = 1

    config IDF_DOC_BUILD
        bool
        default y if "$(IDF_DOC_BUILD)" = "y" || "$(IDF_DOC_BUILD)" = 1

    config IDF_TOOLCHAIN
        # This option records the IDF target when sdkconfig is generated the first time.
        # It is not updated if environment variable $IDF_TOOLCHAIN changes later, and
        # the build system is responsible for detecting the mismatch between
        # CONFIG_IDF_TOOLCHAIN and $IDF_TOOLCHAIN.
        string
        default "$IDF_TOOLCHAIN"

    config IDF_TOOLCHAIN_CLANG
        bool
        default "y" if IDF_TOOLCHAIN="clang"

    config IDF_TARGET_ARCH_RISCV
        bool
        default "n"

    config IDF_TARGET_ARCH_XTENSA
        bool
        default "n"

    config IDF_TARGET_ARCH
        string
        default "riscv" if IDF_TARGET_ARCH_RISCV
        default "xtensa" if IDF_TARGET_ARCH_XTENSA

    config IDF_TARGET
        # This option records the IDF target when sdkconfig is generated the first time.
        # It is not updated if environment variable $IDF_TARGET changes later, and
        # the build system is responsible for detecting the mismatch between
        # CONFIG_IDF_TARGET and $IDF_TARGET.
        string
        default "$IDF_TARGET"

    config IDF_INIT_VERSION
        # This option records the IDF version when sdkconfig is generated the first time.
        # It is not updated if environment variable $IDF_VERSION changes later
        string
        default "$IDF_INIT_VERSION"

    config IDF_TARGET_ESP32
        bool
        default "y" if IDF_TARGET="esp32"
        select IDF_TARGET_ARCH_XTENSA

    config IDF_TARGET_ESP32S2
        bool
        default "y" if IDF_TARGET="esp32s2"
        select FREERTOS_UNICORE
        select IDF_TARGET_ARCH_XTENSA

    config IDF_TARGET_ESP32S3
        bool
        default "y" if IDF_TARGET="esp32s3"
        select IDF_TARGET_ARCH_XTENSA

    config IDF_TARGET_ESP32C3
        bool
        default "y" if IDF_TARGET="esp32c3"
        select FREERTOS_UNICORE
        select IDF_TARGET_ARCH_RISCV

    config IDF_TARGET_ESP32C2
        bool
        default "y" if IDF_TARGET="esp32c2"
        select FREERTOS_UNICORE
        select IDF_TARGET_ARCH_RISCV

    config IDF_TARGET_ESP32C6
        bool
        default "y" if IDF_TARGET="esp32c6"
        select FREERTOS_UNICORE
        select IDF_TARGET_ARCH_RISCV

    config IDF_TARGET_ESP32C5
        bool
        default "y" if IDF_TARGET="esp32c5"
        select FREERTOS_UNICORE
        select IDF_TARGET_ARCH_RISCV

    # TODO: IDF-9197
    choice IDF_TARGET_ESP32C5_VERSION
        prompt "ESP32-C5版本"
        depends on IDF_TARGET_ESP32C5
        default IDF_TARGET_ESP32C5_MP_VERSION
        help
            ESP32-C5将在一段时间内支持两个版本。
            此选项仅供内部使用。
            选择与您的芯片型号匹配的版本。

        config IDF_TARGET_ESP32C5_BETA3_VERSION
            bool
            prompt "ESP32-C5 beta3"
            select ESPTOOLPY_NO_STUB

        config IDF_TARGET_ESP32C5_MP_VERSION
            bool
            prompt "ESP32-C5 MP"
            select ESPTOOLPY_NO_STUB
            select IDF_ENV_FPGA
    endchoice

    config IDF_TARGET_ESP32P4
        bool
        default "y" if IDF_TARGET="esp32p4"
        select IDF_TARGET_ARCH_RISCV

    config IDF_TARGET_ESP32H2
        bool
        default "y" if IDF_TARGET="esp32h2"
        select FREERTOS_UNICORE
        select IDF_TARGET_ARCH_RISCV

    config IDF_TARGET_ESP32C61
        bool
        default "y" if IDF_TARGET="esp32c61"
        select FREERTOS_UNICORE
        select IDF_TARGET_ARCH_RISCV
        select IDF_ENV_FPGA

    config IDF_TARGET_LINUX
        bool
        default "y" if IDF_TARGET="linux"

    config IDF_FIRMWARE_CHIP_ID
        hex
        default 0x0000 if IDF_TARGET_ESP32
        default 0x0002 if IDF_TARGET_ESP32S2
        default 0x0005 if IDF_TARGET_ESP32C3
        default 0x0009 if IDF_TARGET_ESP32S3
        default 0x000C if IDF_TARGET_ESP32C2
        default 0x000D if IDF_TARGET_ESP32C6
        default 0x0010 if IDF_TARGET_ESP32H2
        default 0x0012 if IDF_TARGET_ESP32P4
        default 0x0011 if IDF_TARGET_ESP32C5 && IDF_TARGET_ESP32C5_BETA3_VERSION  # TODO: IDF-9197
        default 0x0017 if IDF_TARGET_ESP32C5 && IDF_TARGET_ESP32C5_MP_VERSION     # TODO: IDF-9197
        default 0x0014 if IDF_TARGET_ESP32C61
        default 0xFFFF


    menu "构建类型"

        choice APP_BUILD_TYPE
            prompt "应用程序构建类型"
            default APP_BUILD_TYPE_APP_2NDBOOT
            help
                选择应用程序的构建方式。

                默认情况下，应用程序被构建为与ESP-IDF引导加载程序兼容的二进制文件格式。除了这个应用程序之外，还会构建第二阶段引导加载程序。应用程序和引导加载程序二进制文件可以写入闪存并从那里加载/执行。

                另一个选项，仅适用于非常小和有限的应用程序，是只链接应用程序的.elf文件，以便可以通过JTAG或UART直接加载到RAM中。请注意，由于IRAM和DRAM大小非常有限，无法以这种方式构建任何复杂的应用程序。然而，对于某些类型的测试和调试，这个选项可能提供更快的迭代，因为应用程序不需要写入闪存。

                注意：当选择APP_BUILD_TYPE_RAM并通过JTAG加载时，ESP-IDF不包含初始化CPU和ROM内存（数据/bss）所需的所有启动代码。因此，在执行应用程序之前，有必要执行一些ROM代码。gdbinit文件可能如下所示（适用于ESP32）：

                    # 连接到正在运行的OpenOCD实例
                    target remote :3333
                    # 重置并暂停目标
                    mon reset halt
                    # 运行到ROM代码中的特定点，
                    # 在那里大部分初始化已完成。
                    thb *0x40007d54
                    c
                    # 将应用程序加载到RAM中
                    load
                    # 运行到app_main
                    tb app_main
                    c

                按如下方式执行此gdbinit文件：

                    xtensa-esp32-elf-gdb build/app-name.elf -x gdbinit

                其他目标的示例gdbinit文件可以在tools/test_apps/system/gdb_loadable_elf/中找到

                使用UART加载BIN时，ROM将在完成ROM启动代码后跳转到RAM并运行应用程序，因此不需要额外的启动初始化。您可以使用esptool.py中的`load_ram`将生成的.bin文件加载到RAM中并执行。

                示例：
                    esptool.py --chip {chip} -p {port} -b {baud} --no-stub load_ram {app.bin}

                构建可加载ELF文件的推荐sdkconfig.defaults如下。
                需要CONFIG_APP_BUILD_TYPE_RAM，其他选项有助于减少应用程序内存占用。

                    CONFIG_APP_BUILD_TYPE_RAM=y
                    CONFIG_VFS_SUPPORT_TERMIOS=
                    CONFIG_NEWLIB_NANO_FORMAT=y
                    CONFIG_ESP_SYSTEM_PANIC_PRINT_HALT=y
                    CONFIG_ESP_DEBUG_STUBS_ENABLE=
                    CONFIG_ESP_ERR_TO_NAME_LOOKUP=


            config APP_BUILD_TYPE_APP_2NDBOOT
                bool
                prompt "默认（二进制应用程序 + 第二阶段引导加载程序）"
                depends on !IDF_TARGET_LINUX
                select APP_BUILD_GENERATE_BINARIES
                select APP_BUILD_BOOTLOADER
                select APP_BUILD_USE_FLASH_SECTIONS

            config APP_BUILD_TYPE_RAM
                bool
                prompt "构建的应用程序完全在RAM中运行（实验性）"
                select APP_BUILD_GENERATE_BINARIES

        endchoice # APP_BUILD_TYPE

        # Hidden options, set according to the choice above
        config APP_BUILD_GENERATE_BINARIES
            bool # Whether to generate .bin files or not

        config APP_BUILD_BOOTLOADER
            bool # Whether to build the bootloader

        config APP_BUILD_TYPE_PURE_RAM_APP
            bool
            prompt "构建应用程序时不包含SPI_FLASH/PSRAM支持（节省RAM）"
            depends on APP_BUILD_TYPE_RAM
            help
                如果启用此选项，外部内存和相关外设（如Cache、MMU、Flash和PSRAM）将不会被初始化。相应的驱动程序也不会被引入。
                依赖于spi_flash组件的组件也将不可用，例如app_update等。启用此选项时，可以节省约26KB的RAM空间。

        config APP_BUILD_USE_FLASH_SECTIONS
            bool # Whether to place code/data into memory-mapped flash sections

        config APP_REPRODUCIBLE_BUILD
            bool "启用可重现构建"
            default n
            select COMPILER_HIDE_PATHS_MACROS
            help
                如果启用，所有日期、时间和路径信息都将被消除。将自动创建一个.gdbinit文件。
                （或者如果您已经有一个，将会追加）

        config APP_NO_BLOBS
            bool "无二进制Blob"
            default n
            help
                如果启用，这将禁用在应用程序构建中链接二进制库。请注意，
                启用此选项后，Wi-Fi/蓝牙将无法工作。

        config APP_COMPATIBLE_PRE_V2_1_BOOTLOADERS
            bool "应用程序与ESP-IDF v2.1之前的引导加载程序兼容"
            select APP_COMPATIBLE_PRE_V3_1_BOOTLOADERS
            depends on IDF_TARGET_ESP32
            default n
            help
                ESP-IDF v2.1之前的引导加载程序对系统时钟进行了较少的初始化。需要启用此设置
                以构建可以由这些较旧的引导加载程序引导的应用程序。

                如果启用此设置，应用程序可以由从IDF v1.0到当前版本的任何引导加载程序引导。

                如果禁用此设置，应用程序只能由IDF v2.1或更新版本的引导加载程序引导。

                启用此设置会使应用程序的IRAM使用量增加约1KB。

        config APP_COMPATIBLE_PRE_V3_1_BOOTLOADERS
            bool "应用程序与ESP-IDF v3.1之前的引导加载程序和分区表兼容"
            depends on IDF_TARGET_ESP32
            default n
            help
                ESP-IDF V3.1之前的分区表不包含MD5校验和字段，
                ESP-IDF v3.1之前的引导加载程序无法读取包含MD5校验和字段的分区表。

                仅当您的应用程序需要在由ESP-IDF v3.1之前的版本生成的引导加载程序和/或
                分区表上引导时，才启用此选项。

                如果同时启用此选项和Flash加密，并且分区表中的任何数据分区被标记为加密，
                则在访问分区之前应在应用程序中手动验证分区加密标志（参见CVE-2021-27926）。

        config APP_INIT_CLK
            bool
            depends on IDF_TARGET_ESP32
            default y if APP_COMPATIBLE_PRE_V2_1_BOOTLOADERS
            default y if APP_BUILD_TYPE_RAM


    endmenu # Build type

    source "$COMPONENT_KCONFIGS_PROJBUILD_SOURCE_FILE"

    menu "编译器选项"

        choice COMPILER_OPTIMIZATION
            prompt "优化级别"
            default COMPILER_OPTIMIZATION_DEBUG
            help
                此选项设置应用程序的编译器优化级别（gcc -O 参数）。

                - "调试"设置将向 CFLAGS 添加 -0g 标志。
                - "大小"设置将向 CFLAGS 添加 -0s 标志。
                - "性能"设置将向 CFLAGS 添加 -O2 标志。
                - "无"设置将向 CFLAGS 添加 -O0 标志。

                "大小"设置会使编译后的代码更小更快，但可能会导致调试时
                难以将代码地址与源文件行相关联。

                "性能"设置会使编译后的代码更大更快，但将更容易将代码地址
                与源文件行相关联。

                "无"设置使用 -O0 产生未经优化的编译代码。

                请注意，自定义优化级别可能不受支持。

                IDF 引导加载程序的编译器优化是单独设置的，
                请参阅 BOOTLOADER_COMPILER_OPTIMIZATION 设置。

            config COMPILER_OPTIMIZATION_DEBUG
                bool "调试 (-Og)"
            config COMPILER_OPTIMIZATION_SIZE
                bool "优化大小 (-Os)"
            config COMPILER_OPTIMIZATION_PERF
                bool "优化性能 (-O2)"
            config COMPILER_OPTIMIZATION_NONE
                bool "无优化调试 (-O0)"

        endchoice

        choice COMPILER_OPTIMIZATION_ASSERTION_LEVEL
            prompt "断言级别"
            default COMPILER_OPTIMIZATION_ASSERTIONS_ENABLE
            help
                断言可以是：

                - 启用。失败时将打印详细的断言信息。这是默认设置。

                - 设置为"静默"以节省代码大小（失败的断言将调用 abort()，但用户
                  需要使用中止地址来找到失败断言的行号。）

                - 完全禁用（不推荐用于大多数配置。）在这种情况下，-DNDEBUG 被添加
                  到 CPPFLAGS。

            config COMPILER_OPTIMIZATION_ASSERTIONS_ENABLE
                prompt "启用"
                bool
                help
                    启用断言。失败时将打印断言内容和行号。

            config COMPILER_OPTIMIZATION_ASSERTIONS_SILENT
                prompt "静默（节省代码大小）"
                bool
                help
                    启用静默断言。失败的断言将调用 abort()，用户需要
                    使用中止地址来找到失败断言的行号。

            config COMPILER_OPTIMIZATION_ASSERTIONS_DISABLE
                prompt "禁用（设置 -DNDEBUG）"
                bool
                help
                    如果禁用断言，-DNDEBUG 将被添加到 CPPFLAGS。

        endchoice # assertions

        choice COMPILER_FLOAT_LIB_FROM
            prompt "编译器浮点库来源"
            default COMPILER_FLOAT_LIB_FROM_RVFPLIB if ESP_ROM_HAS_RVFPLIB
            default COMPILER_FLOAT_LIB_FROM_GCCLIB
            help
                在 libgcc 的软浮点部分中，RISC-V 版本是用 C 编写的，
                并处理 IEEE754 中的所有边缘情况，这使得它更大且性能较慢。

                RVfplib 是一个针对 32 位整数处理器优化的 RISC-V 库，用于单精度和双精度浮点运算。
                RVfplib 是"快速"的，但它与 IEEE 754 标准有一些例外。

            config COMPILER_FLOAT_LIB_FROM_GCCLIB
                bool "libgcc"
            config COMPILER_FLOAT_LIB_FROM_RVFPLIB
                depends on ESP_ROM_HAS_RVFPLIB
                bool "librvfp"
        endchoice # COMPILER_FLOAT_LIB_FROM

        config COMPILER_OPTIMIZATION_ASSERTION_LEVEL
            int
            default 0 if COMPILER_OPTIMIZATION_ASSERTIONS_DISABLE
            default 1 if COMPILER_OPTIMIZATION_ASSERTIONS_SILENT
            default 2 if COMPILER_OPTIMIZATION_ASSERTIONS_ENABLE

        config COMPILER_OPTIMIZATION_CHECKS_SILENT
            bool "在 ESP_RETURN_ON_* 和 ESP_EXIT_ON_* 宏中禁用消息"
            default n
            help
                如果启用，以下检查宏中的错误消息将被丢弃：
                - ESP_RETURN_ON_ERROR
                - ESP_EXIT_ON_ERROR
                - ESP_RETURN_ON_FALSE
                - ESP_EXIT_ON_FALSE

        menuconfig COMPILER_HIDE_PATHS_MACROS
            bool "在二进制文件中替换 ESP-IDF 和项目路径"
            default y
            help
                在展开 __FILE__ 和 __BASE_FILE__ 宏时，将 ESP-IDF 内的路径
                替换为相对于占位符字符串"IDF"的路径，并将项目目录内的路径
                转换为相对路径。

                这允许在构建带有断言或其他嵌入文件路径的代码的项目时，
                二进制文件中不包含 IDF 或项目目录的确切路径。

                此选项向 GCC 命令行传递 -fmacro-prefix-map 选项。要替换二进制文件中
                的其他路径，请修改项目 CMakeLists.txt 文件以传递自定义的 -fmacro-prefix-map 
                或 -ffile-prefix-map 参数。

        menuconfig COMPILER_CXX_EXCEPTIONS
            bool "启用 C++ 异常"
            default n
            help
                启用此选项会使所有 IDF C++ 文件在编译时启用异常支持。

                禁用此选项会在所有编译文件中禁用 C++ 异常支持，任何抛出异常的 libstdc++ 代码
                将会中止。

                目前启用此选项会在用户代码首次抛出异常时增加约 500 字节的堆开销。

        config COMPILER_CXX_EXCEPTIONS_EMG_POOL_SIZE
            int "紧急池大小"
            default 0
            depends on COMPILER_CXX_EXCEPTIONS
            help
                C++ 异常的紧急内存池大小（以字节为单位）。当堆上没有足够的内存来分配
                抛出的异常时，将使用此池来分配内存。

        config COMPILER_CXX_RTTI
            bool "启用 C++ 运行时类型信息 (RTTI)"
            default n
            help
                启用此选项会使所有 C++ 文件在编译时启用 RTTI 支持。
                这会增加二进制大小（通常几十 KB），但允许使用
                dynamic_cast 转换和 typeid 运算符。

        choice COMPILER_STACK_CHECK_MODE
            prompt "栈粉碎保护模式"
            default COMPILER_STACK_CHECK_MODE_NONE
            help
                栈粉碎保护模式。发出额外的代码以检查缓冲区溢出，例如栈
                粉碎攻击。这是通过向具有易受攻击对象的函数添加一个保护
                变量来实现的。在函数进入时初始化保护，然后在函数退出时
                检查。如果保护检查失败，程序将停止。保护有以下模式：

                - 在 NORMAL 模式下（GCC 标志：-fstack-protector），只有调用 alloca 的函数
                  和缓冲区大于 8 字节的函数受到保护。

                - STRONG 模式（GCC 标志：-fstack-protector-strong）类似于 NORMAL，
                  但包括额外的受保护函数 -- 那些有本地数组定义或有本地帧地址引用的函数。

                - 在 OVERALL 模式下（GCC 标志：-fstack-protector-all），所有函数都受到保护。

                模式对代码性能和覆盖范围的影响如下：

                - 性能：NORMAL > STRONG > OVERALL

                - 覆盖范围：NORMAL < STRONG < OVERALL

                性能影响包括增加每个任务所需的栈内存量。

            config COMPILER_STACK_CHECK_MODE_NONE
                bool "无"
            config COMPILER_STACK_CHECK_MODE_NORM
                bool "正常"
            config COMPILER_STACK_CHECK_MODE_STRONG
                bool "强"
            config COMPILER_STACK_CHECK_MODE_ALL
                bool "全面"
        endchoice

        config COMPILER_STACK_CHECK
            bool
            default !COMPILER_STACK_CHECK_MODE_NONE
            help
                栈粉碎保护。

        config COMPILER_WARN_WRITE_STRINGS
            bool "启用 -Wwrite-strings 警告标志"
            default "n"
            help
                为 C/C++ 编译器添加 -Wwrite-strings 标志。

                对于 C，这会给字符串常量赋予 ``const char[]`` 类型，因此
                将其地址复制到非 const 的 ``char *`` 指针时会产生警告。
                这个警告有助于在编译时发现试图写入字符串常量的代码。

                对于 C++，这会警告将字符串字面量转换为 ``char *`` 的已弃用做法。

        config COMPILER_SAVE_RESTORE_LIBCALLS
            bool "启用 -msave-restore 标志以减小代码大小"
            depends on IDF_TARGET_ARCH_RISCV
            help
                向 C/C++ 编译标志添加 -msave-restore。

                当启用此标志时，编译器将调用库函数来在函数序言/尾声中
                保存/恢复寄存器。这会导致整体代码大小减小，但代价是
                性能略有下降。

                此选项仅适用于 RISC-V 目标。

        config COMPILER_DISABLE_GCC12_WARNINGS
            bool "禁用 GCC 12 中引入的新警告"
            default "n"
            help
                如果使用 GCC 12 或更新版本，并且想禁用 GCC 11 中不出现的警告，
                请启用此选项。

        config COMPILER_DISABLE_GCC13_WARNINGS
            bool "禁用 GCC 13 中引入的新警告"
            default "n"
            help
                如果使用 GCC 13 或更新版本，并且想禁用 GCC 12 中不出现的警告，
                请启用此选项。

        config COMPILER_DUMP_RTL_FILES
            bool "在编译期间转储 RTL 文件"
            help
                如果启用，在编译期间将生成 RTL 文件。这些文件
                可以被其他工具使用，例如计算调用图。

        choice COMPILER_RT_LIB
            prompt "编译器运行时库"
            default COMPILER_RT_LIB_CLANGRT if IDF_TOOLCHAIN_CLANG
            default COMPILER_RT_LIB_HOST if IDF_TARGET_LINUX
            default COMPILER_RT_LIB_GCCLIB
            help
                选择编译器使用的运行时库。
                - GCC 工具链仅支持 libgcc。
                - Clang 允许在 libgcc 或 libclang_rt 之间选择。
                - 对于主机构建（"linux" 目标），使用默认库。

            config COMPILER_RT_LIB_GCCLIB
                depends on !IDF_TARGET_LINUX
                bool "libgcc"
            config COMPILER_RT_LIB_CLANGRT
                depends on IDF_TOOLCHAIN_CLANG && !IDF_TARGET_LINUX
                bool "libclang_rt"
            config COMPILER_RT_LIB_HOST
                depends on IDF_TARGET_LINUX
                bool "Host"
        endchoice

        config COMPILER_RT_LIB_NAME
            string
            default "clang_rt.builtins" if COMPILER_RT_LIB_CLANGRT
            default "gcc" if COMPILER_RT_LIB_GCCLIB
            default "" if COMPILER_RT_LIB_HOST

        choice COMPILER_ORPHAN_SECTIONS
            prompt "孤立段处理"
            default COMPILER_ORPHAN_SECTIONS_PLACE
            depends on !IDF_TARGET_LINUX
            help
                如果链接器发现孤立段，它会尝试将孤立段放置在具有相同属性的段之后，
                例如代码与数据、可加载与不可加载等。
                这意味着孤立段可能会被放置在 IDF 链接器脚本定义的段之间。
                这可能导致二进制映像的损坏。在此配置链接器操作。

            config COMPILER_ORPHAN_SECTIONS_WARNING
                bool "放置并警告"
                help
                    放置孤立段并发出警告消息。

            config COMPILER_ORPHAN_SECTIONS_PLACE
                bool "静默放置"
                help
                    放置孤立段而不发出警告/错误消息。
        endchoice

    endmenu # Compiler Options

    menu "组件配置"
        source "$COMPONENT_KCONFIGS_SOURCE_FILE"
    endmenu

    config IDF_EXPERIMENTAL_FEATURES
        bool "显示实验性功能"
        default "n"
        help
            通过启用此选项，ESP-IDF 实验性功能选项将可见。

            请注意，您仍然需要启用特定的实验性功能选项才能使用它，并且
            您应该仔细阅读相应的风险警告和已知问题列表。

            当前实验性功能列表：

            - CONFIG_ESPTOOLPY_FLASHFREQ_120M && CONFIG_ESPTOOLPY_FLASH_SAMPLE_MODE_DTR
            - CONFIG_SPIRAM_SPEED_120M && CONFIG_SPIRAM_MODE_OCT
            - CONFIG_BOOTLOADER_CACHE_32BIT_ADDR_QUAD_FLASH
            - CONFIG_MBEDTLS_USE_CRYPTO_ROM_IMPL
            - CONFIG_ESP_WIFI_EAP_TLS1_3
            - CONFIG_ESP_WIFI_ENABLE_ROAMING_APP
