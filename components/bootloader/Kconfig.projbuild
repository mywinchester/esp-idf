menu "引导加载程序配置"

    orsource "../esp_bootloader_format/Kconfig.bootloader"

    config BOOTLOADER_OFFSET_IN_FLASH
        hex
        default 0x1000 if IDF_TARGET_ESP32 || IDF_TARGET_ESP32S2
        # the first 2 sectors are reserved for the key manager with AES-XTS (flash encryption) purpose
        default 0x2000 if IDF_TARGET_ESP32P4 || IDF_TARGET_ESP32C5
        default 0x0
        help
            第二阶段引导程序将被烧录到的偏移地址。
            该值由ROM引导程序决定。
            在ESP-IDF中不可配置。

    choice BOOTLOADER_COMPILER_OPTIMIZATION
        prompt "引导加载程序优化级别"
        default BOOTLOADER_COMPILER_OPTIMIZATION_SIZE
        help
            此选项设置引导加载程序的编译器优化级别（gcc -O 参数）。

            - 默认的"Size"设置将向CFLAGS添加-0s标志。
            - "Debug"设置将向CFLAGS添加-Og标志。
            - "Performance"设置将向CFLAGS添加-O2标志。

            请注意，自定义优化级别可能不受支持。

        config BOOTLOADER_COMPILER_OPTIMIZATION_SIZE
            bool "大小优化 (-Os)"
        config BOOTLOADER_COMPILER_OPTIMIZATION_DEBUG
            bool "调试 (-Og)"
        config BOOTLOADER_COMPILER_OPTIMIZATION_PERF
            bool "性能优化 (-O2)"
        config BOOTLOADER_COMPILER_OPTIMIZATION_NONE
            bool "不优化 (-O0) (已弃用，将在 IDF v6.0 中移除)"
            depends on IDF_TARGET_ARCH_XTENSA || IDF_TARGET_ESP32C3 || IDF_TARGET_ESP32C2

    endchoice

    choice BOOTLOADER_LOG_LEVEL
        bool "引导加载程序日志详细程度"
        default BOOTLOADER_LOG_LEVEL_INFO
        help
            指定在引导加载程序日志中看到多少输出。

        config BOOTLOADER_LOG_LEVEL_NONE
            bool "无输出"
        config BOOTLOADER_LOG_LEVEL_ERROR
            bool "错误"
        config BOOTLOADER_LOG_LEVEL_WARN
            bool "警告"
        config BOOTLOADER_LOG_LEVEL_INFO
            bool "信息"
        config BOOTLOADER_LOG_LEVEL_DEBUG
            bool "调试"
        config BOOTLOADER_LOG_LEVEL_VERBOSE
            bool "详细"
    endchoice

    config BOOTLOADER_LOG_LEVEL
        int
        default 0 if BOOTLOADER_LOG_LEVEL_NONE
        default 1 if BOOTLOADER_LOG_LEVEL_ERROR
        default 2 if BOOTLOADER_LOG_LEVEL_WARN
        default 3 if BOOTLOADER_LOG_LEVEL_INFO
        default 4 if BOOTLOADER_LOG_LEVEL_DEBUG
        default 5 if BOOTLOADER_LOG_LEVEL_VERBOSE

    menu "串行闪存配置"
        config BOOTLOADER_SPI_CUSTOM_WP_PIN
            bool "当闪存引脚在 eFuse 中设置时使用自定义 SPI 闪存 WP 引脚（阅读帮助）"
            depends on IDF_TARGET_ESP32 && (ESPTOOLPY_FLASHMODE_QIO || ESPTOOLPY_FLASHMODE_QOUT)
            default y if BOOTLOADER_SPI_WP_PIN != 7  # backwards compatibility, can remove in IDF 5
            default n
            help
                仅当通过设置eFuses SPI_PAD_CONFIG_xxx覆盖SPI闪存引脚，且SPI闪存模式为QIO或QOUT时，才使用此设置。

                在这种情况下，eFuse配置仅定义了4个Quad I/O数据引脚中的3个。WP引脚（又称ESP32引脚"SD_DATA_3"或SPI闪存引脚"IO2"）未在eFuse中指定。如果启用了外部SPIRAM，则同一引脚也用于外部SPIRAM。

                如果将此配置项设置为N（默认值），则对于任何具有集成闪存的Espressif芯片或模块，将自动使用正确的WP引脚。如果需要自定义设置，请将此配置项设置为Y并指定连接到WP的GPIO编号。

        config BOOTLOADER_SPI_WP_PIN
            int "自定义 SPI 闪存 WP 引脚"
            range 0 33
            default 7
            depends on IDF_TARGET_ESP32 && (ESPTOOLPY_FLASHMODE_QIO || ESPTOOLPY_FLASHMODE_QOUT)
            #depends on BOOTLOADER_SPI_CUSTOM_WP_PIN  # backwards compatibility, can uncomment in IDF 5
            help
                必须设置"Use custom SPI Flash WP Pin"选项，否则此值将被忽略

                如果在eFuse中烧录了自定义的SPI闪存引脚集，并且使用QIO或QOUT模式进行闪存，请将此值设置为SPI闪存WP引脚的GPIO编号。

        config BOOTLOADER_FLASH_DC_AWARE
            bool "允许应用程序调整 SPI 闪存中的 Dummy Cycle 位以获得更高频率（先阅读帮助）"
            help
                这将强制第二阶段引导加载程序通过DOUT模式加载，并通过重置闪存来恢复Dummy Cycle设置

        config BOOTLOADER_FLASH_XMC_SUPPORT
            bool "启用对 XMC 闪存芯片的支持（先阅读文档）"
            default y
            help
                执行XMC推荐的启动流程。请咨询XMC了解此流程的详细信息。
                禁用此选项时，将禁止使用XMC芯片。

                除非您知道自己在做什么，否则不要禁用此选项。

                comment "Features below require specific hardware (READ DOCS FIRST!)"

        config BOOTLOADER_FLASH_32BIT_ADDR
            bool
            default y if ESPTOOLPY_FLASHSIZE_32MB || ESPTOOLPY_FLASHSIZE_64MB || ESPTOOLPY_FLASHSIZE_128MB
            default n
            help
                这是32位地址闪存的辅助配置。对用户不可见。

        config BOOTLOADER_FLASH_NEEDS_32BIT_FEAT
            bool
            default y if BOOTLOADER_FLASH_32BIT_ADDR && !ESPTOOLPY_OCT_FLASH
            help
                这是32位地址闪存的辅助配置。对用户不可见。

        config BOOTLOADER_CACHE_32BIT_ADDR_QUAD_FLASH
            bool "启用缓存访问 32 位地址（超过 16MB）范围的 SPI 闪存（先阅读文档）"
            depends on BOOTLOADER_FLASH_NEEDS_32BIT_FEAT && IDF_TARGET_ESP32S3 && IDF_EXPERIMENTAL_FEATURES
            default n
            help
                启用此选项允许CPU访问16M范围以外的32位地址闪存。
                1. 此选项仅对4线闪存有效。八线闪存不需要此选项。
                2. 此选项是实验性的，这意味着它不能在所有闪存芯片上稳定使用，如需更多信息，请联系Espressif商业支持。

        config BOOTLOADER_CACHE_32BIT_ADDR_OCTAL_FLASH
            bool
            default y if ESPTOOLPY_OCT_FLASH && BOOTLOADER_FLASH_32BIT_ADDR
            default n

    endmenu

    choice BOOTLOADER_VDDSDIO_BOOST
        bool "VDDSDIO LDO 电压"
        default BOOTLOADER_VDDSDIO_BOOST_1_9V
        depends on SOC_CONFIGURABLE_VDDSDIO_SUPPORTED
        help
            如果启用此选项，并且VDDSDIO LDO设置为1.8V（使用eFuse或MTDI引导引脚），引导加载程序将更改LDO设置以输出1.9V。这有助于防止闪存芯片在闪存编程操作期间出现褐出现象。

            如果VDDSDIO设置为3.3V，或者通过eFuse禁用内部VDDSDIO调节器，则此选项无效。

        config BOOTLOADER_VDDSDIO_BOOST_1_8V
            bool "1.8V"
            depends on !ESPTOOLPY_FLASHFREQ_80M
        config BOOTLOADER_VDDSDIO_BOOST_1_9V
            bool "1.9V"
    endchoice

    config BOOTLOADER_FACTORY_RESET
        bool "GPIO 触发恢复出厂设置"
        default N
        select BOOTLOADER_RESERVE_RTC_MEM if SOC_RTC_FAST_MEM_SUPPORTED
        help
            允许将设备重置为出厂设置：
            - 清除一个或多个数据分区；
            - 从"factory"分区启动。
            如果在设备启动时有一个GPIO输入保持在配置的电平，则会发生出厂重置。请参阅下面的设置。

    config BOOTLOADER_NUM_PIN_FACTORY_RESET
        int "用于恢复出厂设置的 GPIO 输入编号"
        depends on BOOTLOADER_FACTORY_RESET
        range 0 39 if IDF_TARGET_ESP32
        range 0 44 if IDF_TARGET_ESP32S2
        default 4
        help
            选定的GPIO将被配置为带有内部上拉的输入（请注意，在某些SoC上，并非所有引脚都有内部上拉，请查阅硬件数据手册了解详细信息）。要触发出厂重置，此GPIO必须在启动时保持高电平或低电平（根据配置）。

    choice BOOTLOADER_FACTORY_RESET_PIN_LEVEL
        bool "恢复出厂设置 GPIO 电平"
        depends on BOOTLOADER_FACTORY_RESET
        default BOOTLOADER_FACTORY_RESET_PIN_LOW
        help
            出厂重置的引脚电平，可以在低电平或高电平触发。

        config BOOTLOADER_FACTORY_RESET_PIN_LOW
            bool "在 GPIO 低电平时重置"

        config BOOTLOADER_FACTORY_RESET_PIN_HIGH
            bool "在 GPIO 高电平时重置"
    endchoice

    config BOOTLOADER_OTA_DATA_ERASE
        bool "恢复出厂设置时清除 OTA 数据（选择工厂分区）"
        depends on BOOTLOADER_FACTORY_RESET
        help
            出厂重置后，设备将从"factory"分区（如果没有factory分区，则从OTA槽0）启动。

    config BOOTLOADER_DATA_FACTORY_RESET
        string "恢复出厂设置时要清除的分区名称（逗号分隔）"
        depends on BOOTLOADER_FACTORY_RESET
        default "nvs"
        help
            允许客户选择在出厂重置时将擦除哪些数据分区。

            指定分区名称，用逗号分隔，可以添加可选的空格以提高可读性。（例如："nvs, phy_init, ..."）
            确保在分区表和此处指定的名称相同。
            不能在此处指定"app"类型的分区。

    config BOOTLOADER_APP_TEST
        bool "GPIO 触发从测试应用分区启动"
        default N
        depends on !BOOTLOADER_APP_ANTI_ROLLBACK
        help
            允许从"TEST"分区运行测试应用程序。
            如果在设备启动时有一个GPIO输入被拉低，则会从"test"分区启动。
            请参阅下面的设置。

    config BOOTLOADER_NUM_PIN_APP_TEST
        int "用于启动测试分区的 GPIO 输入编号"
        depends on BOOTLOADER_APP_TEST
        range 0 39
        default 18
        help
            选定的GPIO将被配置为带有内部上拉的输入。
            要触发测试应用程序，此GPIO必须在复位时拉低。
            在GPIO输入停用并且设备重新启动后，将启动旧应用程序。
            （factory或OTA[x]）。
            请注意，GPIO34-39没有内部上拉，必须提供外部上拉。

    choice BOOTLOADER_APP_TEST_PIN_LEVEL
        bool "应用测试 GPIO 电平"
        depends on BOOTLOADER_APP_TEST
        default BOOTLOADER_APP_TEST_PIN_LOW
        help
            应用程序测试的引脚电平，可以在低电平或高电平触发。

        config BOOTLOADER_APP_TEST_PIN_LOW
            bool "在 GPIO 低电平时进入测试应用"

        config BOOTLOADER_APP_TEST_PIN_HIGH
            bool "在 GPIO 高电平时进入测试应用"
    endchoice

    config BOOTLOADER_HOLD_TIME_GPIO
        int "重置/测试模式的 GPIO 保持时间（秒）"
        depends on BOOTLOADER_FACTORY_RESET || BOOTLOADER_APP_TEST
        default 5
        help
            复位后，GPIO必须连续保持低电平此时间段，才能执行出厂重置或测试分区启动（视情况而定）。

    config BOOTLOADER_REGION_PROTECTION_ENABLE
        bool "启用对未映射内存区域的保护"
        default y
        help
            保护整个地址空间中未映射的内存区域免受意外访问。
            这将确保当CPU对地址空间的未映射区域执行内存操作时，将触发异常。

    config BOOTLOADER_WDT_ENABLE
        bool "在启动代码中使用 RTC 看门狗"
        default y
        help
            跟踪启动代码的执行时间。
            如果超过执行时间，RTC_WDT将重启系统。
            这也有助于防止由不稳定电源引起的启动代码锁定。
            注意：执行时间跟踪从引导加载程序代码开始 - 重新设置超时，同时选择slow_clk的源 - 并在调用app_main时结束。
            由于WDT使用SLOW_CLK时钟源，因此需要重新设置超时。更改slow_clk频率后，WDT的时间需要重新设置为新频率。
            slow_clk取决于RTC_CLK_SRC（INTERNAL_RC或EXTERNAL_CRYSTAL）。

    config BOOTLOADER_WDT_DISABLE_IN_USER_CODE
        bool "允许在用户代码中禁用 RTC 看门狗"
        depends on BOOTLOADER_WDT_ENABLE
        default n
        help
            如果设置此选项，ESP-IDF应用程序必须在应用程序自己的代码中显式重置、喂狗或禁用rtc_wdt。
            如果未设置此选项（默认），则ESP-IDF将在调用app_main()函数之前禁用rtc_wdt。

            使用函数wdt_hal_feed()来重置RTC_WDT的计数器。
            对于esp32/s2，您还可以使用rtc_wdt_feed()。

            使用函数wdt_hal_disable()来禁用RTC_WDT。
            对于esp32/s2，您还可以使用rtc_wdt_disable()。

    config BOOTLOADER_WDT_TIME_MS
        int "RTC 看门狗超时时间（毫秒）"
        depends on BOOTLOADER_WDT_ENABLE
        default 9000
        range 0 120000
        help
            验证此参数是否正确且大于执行时间。
            注意诸如恢复出厂设置、触发测试分区和启动时加密等选项 - 这些选项可能会增加执行时间。
            注意：在执行加密操作时，RTC_WDT将重置。

    config BOOTLOADER_APP_ROLLBACK_ENABLE
        bool "启用应用程序回滚支持"
        default n
        help
            更新应用程序后，引导加载程序会以"ESP_OTA_IMG_PENDING_VERIFY"状态运行新应用程序。
            此状态防止重新运行此应用程序。在用户代码中首次启动新应用程序后，
            应调用函数来确认应用程序的可操作性或相反的不可操作性。
            如果应用程序正常工作，则将其标记为有效。否则，将其标记为无效并回滚到先前工作的应用程序。
            执行重启，并在软件更新之前启动应用程序。
            注意：如果在新应用程序首次启动期间断电或WDT工作，则会发生回滚。
            回滚仅在具有相同安全版本的应用程序之间可能。

    config BOOTLOADER_APP_ANTI_ROLLBACK
        bool "启用应用程序防回滚支持"
        depends on BOOTLOADER_APP_ROLLBACK_ENABLE
        default n
        help
            此选项防止回滚到具有较低安全版本的先前固件/应用程序映像。

    config BOOTLOADER_APP_SECURE_VERSION
        int "应用程序的 eFuse 安全版本"
        depends on BOOTLOADER_APP_ANTI_ROLLBACK
        default 0
        help
            安全版本是存储在每个固件头部的序列号。
            安全版本在引导加载程序中设置，版本记录在eFuse字段中，
            作为已设置的1的数量。在efuse字段中分配用于存储安全版本的位数是有限的
            （请参阅BOOTLOADER_APP_SEC_VER_SIZE_EFUSE_FIELD选项）。

            引导加载程序：当引导加载程序选择要启动的应用程序时，
            会选择安全版本大于或等于eFuse字段中记录的版本的应用程序。
            应用程序以更高（或相等）的安全版本启动。

            如果在以前的版本中存在重大漏洞且不可接受使用，则值得增加安全版本。

            您的分区表应具有ota_0 + ota_1方案（无工厂分区）。

    config BOOTLOADER_APP_SEC_VER_SIZE_EFUSE_FIELD
        int "eFuse 安全版本字段的大小"
        depends on BOOTLOADER_APP_ANTI_ROLLBACK
        range 1 32 if IDF_TARGET_ESP32
        default 32 if IDF_TARGET_ESP32
        range 1 4 if IDF_TARGET_ESP32C2
        default 4 if IDF_TARGET_ESP32C2
        range 1 16
        default 16
        help
            efuse安全版本字段的大小。
            对于ESP32，其长度限制为32位，对于ESP32-S2，限制为16位。
            这决定了可以增加安全版本的次数。

    config BOOTLOADER_EFUSE_SECURE_VERSION_EMULATE
        bool "模拟 eFuse 安全版本操作（仅用于测试）"
        default n
        depends on BOOTLOADER_APP_ANTI_ROLLBACK
        select EFUSE_VIRTUAL
        select EFUSE_VIRTUAL_KEEP_IN_FLASH
        help
            此选项允许模拟所有eFuses和efuse安全版本的读/写操作。
            它允许在不永久写入eFuse位的情况下测试防回滚实现。
            分区表中应该有一个具有以下详细信息的条目：`emul_efuse, data, efuse, , 0x2000`。

            此选项启用：EFUSE_VIRTUAL和EFUSE_VIRTUAL_KEEP_IN_FLASH。

    config BOOTLOADER_SKIP_VALIDATE_IN_DEEP_SLEEP
        bool "从深度睡眠退出时跳过镜像验证"
        # note: dependencies for this config item are different to other "skip image validation"
        # options, allowing to turn on "allow insecure options" and have secure boot with
        # "skip validation when existing deep sleep". Keeping this to avoid a breaking change,
        # but - as noted in help - it invalidates the integrity of Secure Boot checks
        depends on SOC_RTC_FAST_MEM_SUPPORTED && ((SECURE_BOOT && SECURE_BOOT_INSECURE) || !SECURE_BOOT)
        default n
        select BOOTLOADER_RESERVE_RTC_MEM
        help
            此选项禁用从深度睡眠唤醒时对映像的正常验证（校验和、SHA256和签名）。
            这是在深度睡眠唤醒性能和映像完整性检查之间的权衡。

            仅在您知道自己在做什么时才启用此选项。不应与使用deep_sleep()进入
            并更改活动OTA分区结合使用，因为这将在首次加载新OTA分区时跳过验证。

            如果启用了"允许不安全选项"，则可以在安全引导的情况下启用此选项，
            但强烈建议不要启用它，因为它可能允许绕过安全引导。

    config BOOTLOADER_SKIP_VALIDATE_ON_POWER_ON
        bool "从上电复位时跳过镜像验证（请先阅读帮助）"
        # only available if both Secure Boot and Check Signature on Boot are disabled
        depends on !SECURE_SIGNED_ON_BOOT
        default n
        help
            某些应用程序需要从上电时快速启动。默认情况下，
            整个应用程序二进制文件从闪存中读取并验证，这占用了启动时间的很大一部分。

            启用此选项将在SoC从上电启动时跳过应用程序验证。
            请注意，在这种情况下，引导加载程序无法检测闪存中的应用程序映像是否损坏，
            因此无法安全地回退到不同的应用程序分区。这种类型的闪存损坏虽然不太可能发生，
            但如果存在严重的固件错误或物理损坏，则可能发生。

            在其他类型的复位之后，引导加载程序仍将验证应用程序映像。
            这增加了在软复位后检测到由崩溃导致的闪存损坏的可能性，
            引导加载程序将回退到有效的应用程序映像。为了增加从闪存损坏事件中成功恢复的机会，
            请保持BOOTLOADER_WDT_ENABLE选项启用，并考虑也启用BOOTLOADER_WDT_DISABLE_IN_USER_CODE 
            - 然后在应用程序运行后手动禁用RTC看门狗。此外，启用任务和中断看门狗定时器，并设置复位选项。

    config BOOTLOADER_SKIP_VALIDATE_ALWAYS
        bool "始终跳过镜像验证（请先阅读帮助）"
        # only available if both Secure Boot and Check Signature on Boot are disabled
        depends on !SECURE_SIGNED_ON_BOOT
        default n
        select BOOTLOADER_SKIP_VALIDATE_IN_DEEP_SLEEP if SOC_RTC_FAST_MEM_SUPPORTED
        select BOOTLOADER_SKIP_VALIDATE_ON_POWER_ON
        help
            选择此选项可防止引导加载程序在启动应用程序映像之前进行验证。
            所选应用程序分区的任何闪存损坏都将使整个SoC无法启动。

            尽管闪存损坏是一种非常罕见的情况，但不建议选择此选项。
            考虑选择"从上电复位跳过映像验证"。但是，如果启动时间是唯一重要的因素，则可以启用它。

    config BOOTLOADER_RESERVE_RTC_SIZE
        hex
        depends on SOC_RTC_FAST_MEM_SUPPORTED
        default 0x10 if BOOTLOADER_RESERVE_RTC_MEM
        default 0
        help
            为跳过映像验证保留RTC FAST内存。此选项以字节为单位。
            此选项在RTC FAST内存中保留一个区域（仅PRO_CPU访问）。
            用于保存所选应用程序的地址。
            当发生唤醒（从深度睡眠）时，引导加载程序检索它并
            无需验证即可加载应用程序。

    config BOOTLOADER_CUSTOM_RESERVE_RTC
        bool "为自定义目的保留 RTC FAST 内存"
        depends on SOC_RTC_FAST_MEM_SUPPORTED
        select BOOTLOADER_RESERVE_RTC_MEM
        default n
        help
            此选项允许客户在RTC FAST内存中放置数据，
            此区域在重新启动时保持有效，电源损失除外。
            此内存位于固定地址，可供引导加载程序和应用程序使用。
            （应用程序和引导加载程序必须使用相同的选项进行编译）。
            RTC FAST内存仅通过PRO_CPU访问。

    config BOOTLOADER_CUSTOM_RESERVE_RTC_IN_CRC
        bool "在 CRC 计算中包含自定义内存"
        depends on BOOTLOADER_CUSTOM_RESERVE_RTC
        default n
        help
            此选项允许客户使用旧的引导加载程序行为，
            即在RTC FAST内存CRC计算中包含自定义数据。
            启用此选项后，分配的用户自定义数据将被纳入CRC计算中。
            这意味着对自定义数据的任何更改都需要更新CRC，
            以防止引导加载程序将此数据标记为损坏。
            如果禁用此选项，则在计算RTC FAST内存CRC时不会考虑自定义数据。
            用户自定义数据可以自由更改，无需更新CRC。
            此选项必须在引导加载程序和应用程序构建中保持一致。

    config BOOTLOADER_CUSTOM_RESERVE_RTC_SIZE
        hex "为自定义目的保留的字节大小"
        default 0
        depends on BOOTLOADER_CUSTOM_RESERVE_RTC
        help
            此选项在RTC FAST内存中为自定义目的保留区域。
            如果您想创建自己的引导加载程序并在此内存区域中保存更多信息，
            可以增加它。它必须是4字节的倍数。
            此区域（rtc_retain_mem_t）是保留的，可以从引导加载程序和应用程序访问。

    config BOOTLOADER_RESERVE_RTC_MEM
        bool
        depends on SOC_RTC_FAST_MEM_SUPPORTED
        help
            此选项为以下功能在RTC FAST内存中保留一个区域：
            - "从深度睡眠退出时跳过映像验证"
            - "为自定义目的保留RTC FAST内存"
            - "GPIO触发恢复出厂设置"

endmenu  # Bootloader


menu "安全功能"

    # These three are the actual options to check in code,
    # selected by the displayed options
    config SECURE_SIGNED_ON_BOOT
        bool
        default y
        depends on SECURE_BOOT || SECURE_SIGNED_ON_BOOT_NO_SECURE_BOOT

    config SECURE_SIGNED_ON_UPDATE
        bool
        default y
        depends on SECURE_BOOT || SECURE_SIGNED_ON_UPDATE_NO_SECURE_BOOT

    config SECURE_SIGNED_APPS
        bool
        default y
        select MBEDTLS_ECP_DP_SECP256R1_ENABLED
        select MBEDTLS_ECP_C
        select MBEDTLS_ECDH_C
        select MBEDTLS_ECDSA_C
        depends on SECURE_SIGNED_ON_BOOT || SECURE_SIGNED_ON_UPDATE

    config SECURE_BOOT_V2_RSA_SUPPORTED
        bool
        default y
        # RSA secure boot is supported in ESP32 revision >= v3.0
        depends on (IDF_TARGET_ESP32 && ESP32_REV_MIN_FULL >= 300) || SOC_SECURE_BOOT_V2_RSA

    config SECURE_BOOT_V2_ECC_SUPPORTED
        bool
        default y
        depends on SOC_SECURE_BOOT_V2_ECC

    config SECURE_BOOT_V1_SUPPORTED
        bool
        default y
        depends on SOC_SECURE_BOOT_V1

    config SECURE_BOOT_V2_PREFERRED
        bool
        default y
        depends on ESP32_REV_MIN_FULL >= 300

    config SECURE_BOOT_V2_ECDSA_ENABLED
        bool
        default y if SECURE_BOOT_V2_ENABLED && SECURE_BOOT_V2_ECC_SUPPORTED

    config SECURE_BOOT_V2_RSA_ENABLED
        bool
        default y if SECURE_BOOT_V2_ENABLED && SECURE_BOOT_V2_RSA_SUPPORTED

    config SECURE_BOOT_FLASH_ENC_KEYS_BURN_TOGETHER
        bool
        default y if SOC_EFUSE_CONSISTS_OF_ONE_KEY_BLOCK && SECURE_BOOT && SECURE_FLASH_ENC_ENABLED
        # ESP32-C2 has one key block for SB and FE keys. These keys must be burned at the same time.

    config SECURE_SIGNED_APPS_NO_SECURE_BOOT
        bool "需要签名的应用程序镜像"
        depends on !SECURE_BOOT
        help
            要求应用程序镜像被签名以验证其完整性。

            此选项使用与硬件安全启动相同的应用程序签名方案，但与硬件安全启动不同，它不会阻止引导加载程序被物理更新。这意味着设备可以防止远程网络访问，但不能防止物理访问。与使用硬件安全启动相比，此选项实现起来要简单得多。

    choice SECURE_SIGNED_APPS_SCHEME
        bool "应用程序签名方案"
        depends on SECURE_BOOT || SECURE_SIGNED_APPS_NO_SECURE_BOOT
        default SECURE_SIGNED_APPS_ECDSA_SCHEME if SECURE_BOOT_V1_ENABLED
        default SECURE_SIGNED_APPS_RSA_SCHEME if SECURE_BOOT_V2_RSA_SUPPORTED
        default SECURE_SIGNED_APPS_ECDSA_V2_SCHEME if SECURE_BOOT_V2_ECC_SUPPORTED
        help
            选择安全应用程序签名方案。取决于芯片版本。
            有两个安全启动版本：

            1. 安全启动 V1
                - 传统的自定义安全启动方案。在 ESP32 SoC 中支持。

            2. 安全启动 V2
                - 基于 RSA 的安全启动方案。
                  在 ESP32-ECO3（ESP32 芯片版本 3 及以后）、ESP32-S2、ESP32-C3、ESP32-S3 SoCs 中支持。

                - 基于 ECDSA 的安全启动方案。在 ESP32-C2 SoC 中支持。

        config SECURE_SIGNED_APPS_ECDSA_SCHEME
            bool "ECDSA"
            depends on SECURE_BOOT_V1_SUPPORTED && (SECURE_SIGNED_APPS_NO_SECURE_BOOT || SECURE_BOOT_V1_ENABLED)
            help
                在引导加载程序中嵌入 ECDSA 公钥，并使用 ECDSA 密钥签名应用程序。
                启用前请参考文档。

        config SECURE_SIGNED_APPS_RSA_SCHEME
            bool "RSA"
            depends on SECURE_BOOT_V2_RSA_SUPPORTED && (SECURE_SIGNED_APPS_NO_SECURE_BOOT || SECURE_BOOT_V2_ENABLED)
            help
                将基于 RSA-3072 的签名块附加到应用程序。
                启用前请参考<安全启动版本 2 文档链接>。

        config SECURE_SIGNED_APPS_ECDSA_V2_SCHEME
            bool "ECDSA (V2)"
            depends on SECURE_BOOT_V2_ECC_SUPPORTED && (SECURE_SIGNED_APPS_NO_SECURE_BOOT || SECURE_BOOT_V2_ENABLED)
            help
                对于安全启动 V2（例如，ESP32-C2 SoC），将基于 ECDSA 的签名块附加到应用程序。
                启用前请参考文档。

    endchoice

    choice SECURE_BOOT_ECDSA_KEY_LEN_SIZE
        bool "ECDSA 密钥大小"
        depends on SECURE_SIGNED_APPS_ECDSA_V2_SCHEME
        default SECURE_BOOT_ECDSA_KEY_LEN_256_BITS
        help
            选择 ECDSA 密钥大小。支持两种密钥大小

            - 使用 NISTP192 曲线的 192 位密钥
            - 使用 NISTP256 曲线的 256 位密钥（推荐）

            使用 256 位密钥的优势在于额外的随机性，使其比 192 位密钥更难被暴力破解。
            目前，这两种密钥大小在实际中都不太可能被暴力破解。

        config SECURE_BOOT_ECDSA_KEY_LEN_192_BITS
            bool "使用 ECC 曲线 NISTP192"
            depends on SECURE_SIGNED_APPS_ECDSA_V2_SCHEME

        config SECURE_BOOT_ECDSA_KEY_LEN_256_BITS
            bool "使用 ECC 曲线 NISTP256（推荐）"
            depends on SECURE_SIGNED_APPS_ECDSA_V2_SCHEME

    endchoice

    config SECURE_SIGNED_ON_BOOT_NO_SECURE_BOOT
        bool "引导加载程序验证应用程序签名"
        default n
        depends on SECURE_SIGNED_APPS_NO_SECURE_BOOT && SECURE_SIGNED_APPS_ECDSA_SCHEME
        help
            如果设置此选项，引导加载程序将被编译为在启动应用程序之前验证应用程序是否已签名。

            如果启用了硬件安全启动，此选项始终启用且无法禁用。
            如果未启用硬件安全启动，此选项本身并不会增加显著的安全性，因此大多数用户会希望将其保持禁用状态。

    config SECURE_SIGNED_ON_UPDATE_NO_SECURE_BOOT
        bool "在更新时验证应用程序签名"
        default y
        depends on SECURE_SIGNED_APPS_NO_SECURE_BOOT
        help
            如果设置此选项，任何 OTA 更新的应用程序在被视为有效之前都将进行签名验证。

            启用后，每当使用 esp_ota_ops.h API 进行 OTA 更新或使用 esp_image_format.h API 验证应用程序时，都会自动检查签名。

            如果启用了硬件安全启动，此选项始终启用且无法禁用。
            如果未启用硬件安全启动，此选项仍然通过防止 OTA 更新的欺骗来增加显著的安全性，以防止基于网络的攻击者。

    config SECURE_BOOT
        bool "在引导加载程序中启用硬件安全启动（请先阅读文档）"
        default n
        # Secure boot is not supported for ESP32-C3 revision < v0.3
        depends on SOC_SECURE_BOOT_SUPPORTED && !(IDF_TARGET_ESP32C3 && ESP32C3_REV_MIN_FULL < 3)
        select ESPTOOLPY_NO_STUB if !IDF_TARGET_ESP32 && !IDF_TARGET_ESP32S2
        help
            构建一个在首次启动时启用安全启动的引导加载程序。

            一旦启用，安全启动将不会启动修改过的引导加载程序。引导加载程序只会加载经过验证数字签名的分区表或应用程序。启用安全启动后，重新刷写更新的应用程序会有一些影响。

            启用安全启动时，默认情况下 JTAG 和 ROM BASIC 解释器将被永久禁用。

    choice SECURE_BOOT_VERSION
        bool "选择安全启动版本"
        default SECURE_BOOT_V2_ENABLED if SECURE_BOOT_V2_PREFERRED
        depends on SECURE_BOOT
        help
            选择安全启动版本。取决于芯片版本。
            安全启动 V2 是新的基于 RSA / ECDSA 的安全启动方案。

                - 基于 RSA 的方案在 ESP32（版本 3 及以后）、ESP32-S2、ESP32-C3（ECO3）、ESP32-S3 中支持。
                - 基于 ECDSA 的方案在 ESP32-C2 SoC 中支持。

            请注意，RSA 或 ECDSA 安全启动是特定 SoC 的属性，基于其硬件设计、支持的加密加速器、芯片大小、成本等参数。请注意，RSA 方案需要更大的密钥大小，但同时比 ECDSA 验证更快。

            安全启动 V1 是基于 AES 的（自定义）安全启动方案，在 ESP32 SoC 中支持。

        config SECURE_BOOT_V1_ENABLED
            bool "启用安全启动版本 1"
            depends on SECURE_BOOT_V1_SUPPORTED
            help
                构建一个在首次启动时启用安全启动版本 1 的引导加载程序。
                启用前请参考 ESP-IDF 程序员指南中的安全启动部分。

        config SECURE_BOOT_V2_ENABLED
            bool "启用安全启动版本 2"
            depends on SECURE_BOOT_V2_RSA_SUPPORTED || SECURE_BOOT_V2_ECC_SUPPORTED
            help
                构建一个在首次启动时启用安全启动版本 2 的引导加载程序。
                启用前请参考 ESP-IDF 程序员指南中的安全启动 V2 部分。

    endchoice

    choice SECURE_BOOTLOADER_MODE
        bool "安全引导加载程序模式"
        depends on SECURE_BOOT_V1_ENABLED
        default SECURE_BOOTLOADER_ONE_TIME_FLASH

        config SECURE_BOOTLOADER_ONE_TIME_FLASH
            bool "一次性刷写"
            help
                在首次启动时，引导加载程序将生成一个外部不可读且软件不可读的密钥。从引导加载程序镜像本身生成一个摘要。此摘要将在每次后续启动时进行验证。

                启用此选项意味着引导加载程序在首次启动后无法更改。

        config SECURE_BOOTLOADER_REFLASHABLE
            bool "可重新刷写"
            help
                生成一个可重用的安全引导加载程序密钥，从安全启动签名密钥派生（通过 SHA-256）。

                这允许拥有安全启动签名密钥的人重新刷写安全引导加载程序。

                此选项比一次性刷写的安全性较低，因为一个设备的摘要密钥泄露允许重新刷写任何使用它的设备。

    endchoice

    config SECURE_BOOT_BUILD_SIGNED_BINARIES
        bool "在构建过程中签名二进制文件"
        depends on SECURE_SIGNED_APPS
        default y
        help
            一旦启用安全启动或签名应用程序要求，应用程序镜像需要被签名。

            如果启用（默认），这些二进制文件将作为构建过程的一部分被签名。"安全启动私有签名密钥"中命名的文件将用于签名镜像。

            如果禁用，将构建未签名的应用程序/分区数据。它们必须使用 espsecure.py 手动签名。
            版本 1 用于启用基于 ECDSA 的安全启动，版本 2 用于启用基于 RSA 的安全启动。
            （例如，在远程签名服务器上。）

    config SECURE_BOOT_SIGNING_KEY
        string "安全启动私有签名密钥"
        depends on SECURE_BOOT_BUILD_SIGNED_BINARIES
        default "secure_boot_signing_key.pem"
        help
            用于签名应用程序镜像的密钥文件的路径。

            对于安全启动 V1，密钥文件是 PEM 格式的 ECDSA 私钥（NIST256p 曲线）。
            对于安全启动 V2，密钥文件是 PEM 格式的 RSA 私钥。

            路径相对于项目目录进行评估。

            您可以通过运行以下命令生成新的签名密钥：
            espsecure.py generate_signing_key secure_boot_signing_key.pem

            有关详细信息，请参阅 ESP-IDF 程序员指南中的安全启动部分。

    config SECURE_BOOT_VERIFICATION_KEY
        string "安全启动公共签名验证密钥"
        depends on SECURE_SIGNED_APPS && SECURE_SIGNED_APPS_ECDSA_SCHEME && !SECURE_BOOT_BUILD_SIGNED_BINARIES
        default "signature_verification_key.bin"
        help
            用于验证已签名镜像的公钥文件的路径。
            安全启动 V1：此 ECDSA 公钥被编译到引导加载程序和/或
            应用程序中，用于验证应用程序镜像。

            密钥文件采用原始二进制格式，可以使用 espsecure.py
            extract_public_key 命令从 PEM 格式的私钥中提取。

            在启用此选项之前，请参阅此版本 ESP-IDF 程序员指南中的安全启动部分。

    config SECURE_BOOT_ENABLE_AGGRESSIVE_KEY_REVOKE
        bool "启用激进的密钥撤销策略"
        depends on SECURE_BOOT && SOC_SUPPORT_SECURE_BOOT_REVOKE_KEY
        default N
        help
            如果设置此选项，ROM 引导加载程序将在使用 efuse 块中烧录的公钥摘要验证软件引导加载程序签名失败时撤销该公钥摘要。
            启用安全启动时不会发生密钥撤销。一旦启用安全启动，
            密钥撤销检查将在后续启动时进行，同时验证软件引导加载程序。

            此功能为设备提供了强大的物理攻击防御能力。

            注意：一旦摘要槽被撤销，它将永远无法再用于验证镜像
            这可能导致设备永久无法使用，如果由于签名验证失败而撤销所有密钥。

    config SECURE_BOOT_FLASH_BOOTLOADER_DEFAULT
        bool "在使用默认刷写命令时刷写引导加载程序以及其他工件"
        depends on SECURE_BOOT_V2_ENABLED && SECURE_BOOT_BUILD_SIGNED_BINARIES
        default N
        help
            当启用安全启动 V2 时，默认情况下引导加载程序不会与其他工件（如应用程序和分区表镜像）一起刷写，
            即引导加载程序必须使用命令 `idf.py bootloader flash` 单独刷写，
            而应用程序和分区表可以使用命令 `idf.py flash` 本身刷写。
            启用此选项允许通过调用命令 `idf.py flash` 将引导加载程序与其他工件一起刷写。

            如果启用此选项，请确保引导加载程序也使用正确的安全启动密钥进行签名，
            否则引导加载程序签名验证将失败，因为存在于引导加载程序签名中的公钥哈希
            将与存储在 efuse 中的摘要不匹配，因此设备将无法启动。

    choice SECURE_BOOTLOADER_KEY_ENCODING
        bool "硬件密钥编码"
        depends on SECURE_BOOTLOADER_REFLASHABLE
        default SECURE_BOOTLOADER_KEY_ENCODING_256BIT
        help

            在可重新刷写的安全引导加载程序模式下，从签名密钥（使用 SHA-256）派生硬件密钥，
            并可以使用 espefuse.py 写入 eFuse。

            通常这是一个 256 位密钥，但如果在设备上使用 3/4 编码方案，则 eFuse 密钥将
            截断为 192 位。

            此配置项不会更改任何固件代码，它只会更改在构建时生成的密钥二进制文件的大小。

        config SECURE_BOOTLOADER_KEY_ENCODING_256BIT
            bool "无编码（256 位密钥）"

        config SECURE_BOOTLOADER_KEY_ENCODING_192BIT
            bool "3/4 编码（192 位密钥）"

    endchoice

    config SECURE_BOOT_INSECURE
        bool "允许潜在不安全的选项"
        depends on SECURE_BOOT
        default N
        help
            您可以禁用安全启动提供的一些默认保护，以启用测试或
            自定义安全功能组合。

            仅在非常确定的情况下启用这些选项。

            在启用之前，请参阅此版本 ESP-IDF 程序员指南中的安全启动部分。

    config SECURE_FLASH_ENC_ENABLED
        bool "在启动时启用闪存加密（先阅读文档）"
        default N
        select SPI_FLASH_ENABLE_ENCRYPTED_READ_WRITE
        help
            如果设置此选项，引导加载程序将在首次启动时对闪存内容进行加密。

            注意：首次启动后，系统将永久加密。重新刷写加密系统
            是复杂的，并非总是可能的。

            在启用之前，请阅读 https://docs.espressif.com/projects/esp-idf/en/latest/security/flash-encryption.html。

    choice SECURE_FLASH_ENCRYPTION_KEYSIZE
        bool "生成的 XTS-AES 密钥大小"
        default SECURE_FLASH_ENCRYPTION_AES128
        depends on SOC_FLASH_ENCRYPTION_XTS_AES_OPTIONS && SECURE_FLASH_ENC_ENABLED
        help
            生成的 XTS-AES 密钥的大小。

            - AES-128 使用 256 位密钥（32 字节），从烧录在半个 Efuse 密钥块中的 128 位（16 字节）派生。
              内部计算 SHA256(128 位)
            - AES-128 使用 256 位密钥（32 字节），占用一个 Efuse 密钥块。
            - AES-256 使用 512 位密钥（64 字节），占用两个 Efuse 密钥块。

            如果在首次启动之前已经将任一类型的密钥烧录到 Efuse 中，则此设置将被忽略。
            在这种情况下，将使用预烧录的密钥，不会生成新密钥。

        config SECURE_FLASH_ENCRYPTION_AES128_DERIVED
            bool "AES-128 密钥从 128 位派生（SHA256(128 位)）"
            depends on SOC_FLASH_ENCRYPTION_XTS_AES_128_DERIVED

        config SECURE_FLASH_ENCRYPTION_AES128
            bool "AES-128（256 位密钥）"
            depends on SOC_FLASH_ENCRYPTION_XTS_AES_128 && !(IDF_TARGET_ESP32C2 && SECURE_BOOT)

        config SECURE_FLASH_ENCRYPTION_AES256
            bool "AES-256（512 位密钥）"
            depends on SOC_FLASH_ENCRYPTION_XTS_AES_256
    endchoice

    choice SECURE_FLASH_ENCRYPTION_MODE
        bool "启用使用模式"
        depends on SECURE_FLASH_ENC_ENABLED
        default SECURE_FLASH_ENCRYPTION_MODE_DEVELOPMENT
        help
            默认情况下，启用开发模式，允许 ROM 下载模式执行闪存加密
            操作（明文发送到设备，设备内部加密并将密文写入闪存）。此模式不安全，
            攻击者可以将自己选择的明文写入闪存。

            生产或制造时应始终选择发布模式。一旦启用，设备在 ROM 下载模式下
            将无法再使用闪存加密硬件。

            当启用 EFUSE_VIRTUAL 时，SECURE_FLASH_ENCRYPTION_MODE_RELEASE 不可用。
            对于 CI 测试，我们使用 IDF_CI_BUILD 来绕过它（"export IDF_CI_BUILD=1"）。
            我们不建议出于其他目的绕过它。

            有关详细信息，请参阅 ESP-IDF 程序员指南中的闪存加密部分。

        config SECURE_FLASH_ENCRYPTION_MODE_DEVELOPMENT
            bool "开发（不安全）"
            select SECURE_FLASH_UART_BOOTLOADER_ALLOW_ENC

        config SECURE_FLASH_ENCRYPTION_MODE_RELEASE
            bool "发布"
            select PARTITION_TABLE_MD5 if !APP_COMPATIBLE_PRE_V3_1_BOOTLOADERS
            depends on !EFUSE_VIRTUAL || IDF_CI_BUILD

    endchoice

    config SECURE_FLASH_HAS_WRITE_PROTECTION_CACHE
        bool
        default y if (SOC_EFUSE_DIS_ICACHE || IDF_TARGET_ESP32) && SECURE_FLASH_ENC_ENABLED

    menu "潜在不安全的选项"
        visible if (SECURE_FLASH_ENCRYPTION_MODE_DEVELOPMENT || \
            SECURE_BOOT_INSECURE || \
            SECURE_SIGNED_ON_UPDATE_NO_SECURE_BOOT) # NOERROR

        # NOTE: Options in this menu NEED to have SECURE_BOOT_INSECURE
        # and/or SECURE_FLASH_ENCRYPTION_MODE_DEVELOPMENT in "depends on", as the menu
        # itself doesn't enable/disable its children (if it's not set,
        # it's possible for the insecure menu to be disabled but the insecure option
        # to remain on which is very bad.)

        config SECURE_BOOT_ALLOW_ROM_BASIC
            bool "在复位时保留 ROM BASIC 解释器可用"
            depends on (SECURE_BOOT_INSECURE || SECURE_FLASH_ENCRYPTION_MODE_DEVELOPMENT) && IDF_TARGET_ESP32
            default N
            help
                默认情况下，如果从闪存中未读取有效的引导加载程序，
                BASIC ROM 控制台将在复位时启动。

                当启用闪存加密或安全启动时，默认情况下是
                通过 eFuse 永久禁用此 BASIC 回退模式。

                如果设置此选项，则不会烧录此 eFuse，BASIC ROM 控制台可能
                仍然可以访问。仅在测试环境中设置此选项。

        config SECURE_BOOT_ALLOW_JTAG
            bool "允许 JTAG 调试"
            depends on SECURE_BOOT_INSECURE || SECURE_FLASH_ENCRYPTION_MODE_DEVELOPMENT
            select SECURE_FLASH_SKIP_WRITE_PROTECTION_CACHE if SECURE_FLASH_HAS_WRITE_PROTECTION_CACHE
            default N
            help
                如果未设置（默认），当启用安全启动或闪存加密时，引导加载程序将在首次启动时
                永久禁用 JTAG（整个芯片范围）。

                设置此选项将保留 JTAG 用于调试，这会否定闪存加密的所有保护
                和安全启动的一些保护。

                仅在测试环境中设置此选项。

        config SECURE_BOOT_ALLOW_SHORT_APP_PARTITION
            bool "允许应用程序分区长度不是 64KB 对齐"
            depends on SECURE_BOOT_INSECURE || SECURE_SIGNED_ON_UPDATE_NO_SECURE_BOOT
            help
                如果未设置（默认），应用程序分区大小必须是 64KB 的倍数。应用程序镜像被填充到 64KB
                长度，引导加载程序检查签名后的任何尾随字节（在下一个 64KB
                边界之前）是否未被写入。这是因为闪存缓存将整个 64KB 页面映射到地址
                空间。这可以防止攻击者在闪存中的应用程序镜像之后附加未经验证的数据，
                导致它被映射到地址空间。

                设置此选项允许应用程序分区长度不对齐，并禁用将应用程序
                镜像填充到此长度。通常不建议设置此选项，除非您有一个遗留
                分区方案，不支持 64KB 对齐的分区长度。

        config SECURE_BOOT_V2_ALLOW_EFUSE_RD_DIS
            bool "允许额外的 efuse 读保护"
            depends on SECURE_BOOT_INSECURE && SECURE_BOOT_V2_ENABLED
            help
                如果未设置（默认，推荐），在首次启动时，当启用安全启动时，引导加载程序将烧录 WR_DIS_RD_DIS
                efuse。这可以防止更多的 efuse 被读保护。

                如果设置此选项，在启用安全启动后，仍然可以写入 EFUSE_RD_DIS efuse 字段。这可能允许
                攻击者读保护 BLK2 efuse（对于 ESP32）和
                BLOCK4-BLOCK10（即 BLOCK_KEY0-BLOCK_KEY5）（对于其他芯片）持有公钥摘要，导致
                立即拒绝服务，并可能允许额外的故障注入攻击
                绕过签名保护。

                注意：一旦 BLOCK 被读保护，应用程序将从该块读取全零

                注意：如果设置了"UART ROM 下载模式（永久禁用（推荐））"或
                "UART ROM 下载模式（永久切换到安全模式（推荐））"，
                则__无法__使用 espefuse.py 实用程序读/写 efuse。
                但是，可以从应用程序中读/写 efuse

        config SECURE_BOOT_ALLOW_UNUSED_DIGEST_SLOTS
            bool "保留未使用的摘要槽可用（不撤销）"
            depends on SECURE_BOOT_INSECURE && SOC_EFUSE_REVOKE_BOOT_KEY_DIGESTS
            default N
            help
                如果未设置（默认），在应用程序启动期间，所有未使用的摘要槽将被撤销。
                要撤销未使用的槽，将为每个摘要调用 esp_efuse_set_digest_revoke(num_digest)。
                撤销未使用的摘要槽可确保攻击者无法在以后添加受信任的密钥。

                请注意，如果您计划在首次启动时启用安全启动，即使上述配置已启用，引导加载程序也会在启用安全启动时有意
                撤销未使用的摘要槽，因为保持未使用的密钥槽未撤销会构成安全隐患。
                如果在任何开发工作流程中需要避免这种撤销，您应该通过外部方式（基于主机的机制）启用安全启动，
                而不是在启动过程中启用它，这样引导加载程序就不需要启用安全启动，从而可以避免其撤销策略。

        config SECURE_FLASH_UART_BOOTLOADER_ALLOW_ENC
            bool "保留 UART 引导加载程序加密功能启用"
            depends on SECURE_FLASH_ENCRYPTION_MODE_DEVELOPMENT
            select SECURE_FLASH_SKIP_WRITE_PROTECTION_CACHE if SECURE_FLASH_HAS_WRITE_PROTECTION_CACHE
            default N
            help
                如果未设置（默认），引导加载程序将在首次启动时永久禁用 UART 引导加载程序加密访问。
                如果设置，UART 引导加载程序仍然能够访问硬件加密。

                建议仅在测试环境中设置此选项。

        config SECURE_FLASH_UART_BOOTLOADER_ALLOW_DEC
            bool "保留 UART 引导加载程序解密功能启用"
            depends on SECURE_FLASH_ENCRYPTION_MODE_DEVELOPMENT && IDF_TARGET_ESP32
            default N
            help
                如果未设置（默认），引导加载程序将在首次启动时永久禁用 UART 引导加载程序解密访问。
                如果设置，UART 引导加载程序仍然能够访问硬件解密。

                仅在测试环境中设置此选项。设置此选项允许完全绕过闪存加密。

        config SECURE_FLASH_UART_BOOTLOADER_ALLOW_CACHE
            bool "保留 UART 引导加载程序闪存缓存启用"
            depends on SECURE_FLASH_ENCRYPTION_MODE_DEVELOPMENT && \
                (IDF_TARGET_ESP32 || SOC_EFUSE_DIS_DOWNLOAD_ICACHE || SOC_EFUSE_DIS_DOWNLOAD_DCACHE) # NOERROR
            default N
            select SECURE_FLASH_SKIP_WRITE_PROTECTION_CACHE if SECURE_FLASH_HAS_WRITE_PROTECTION_CACHE
            help
                如果未设置（默认），引导加载程序将在首次启动时永久禁用 UART 引导加载程序闪存缓存访问。
                如果设置，UART 引导加载程序仍然能够访问闪存缓存。

                仅在测试环境中设置此选项。

        config SECURE_FLASH_REQUIRE_ALREADY_ENABLED
            bool "要求闪存加密已经启用"
            depends on SECURE_FLASH_ENCRYPTION_MODE_DEVELOPMENT
            default N
            help
                如果未设置（默认），并且闪存加密尚未在 eFuses 中启用，第二阶段引导加载程序
                将启用闪存加密：生成闪存加密密钥并编程 eFuses。
                如果设置此选项，并且闪存加密尚未启用，引导加载程序将报错并重新启动。
                如果闪存加密已在 eFuses 中启用，此选项不会改变引导加载程序的行为。

                仅在测试环境中使用此选项，以避免在错误的设备上意外启用闪存加密。
                设备需要使用 espefuse.py 已经启用闪存加密。

        config SECURE_FLASH_SKIP_WRITE_PROTECTION_CACHE
            bool "跳过 DIS_CACHE（DIS_ICACHE、DIS_DCACHE）的写保护"
            default n
            depends on SECURE_FLASH_HAS_WRITE_PROTECTION_CACHE
            help
                如果未设置（默认，推荐），在首次启动时，当启用闪存加密时，引导加载程序将烧录
                DIS_CACHE（对于 ESP32）或 DIS_ICACHE/DIS_DCACHE（对于其他芯片）eFuse 的写保护。
                缓存禁用 efuse 的写保护可防止芯片因意外设置而被阻塞。
                应用程序和引导加载程序使用缓存，因此禁用它会使芯片对 IDF 无用。
                由于其他 eFuses 与相同的写保护位相关联（见下面的列表），如果选择了
                SECURE_FLASH_UART_BOOTLOADER_ALLOW_ENC、SECURE_BOOT_ALLOW_JTAG 或
                SECURE_FLASH_UART_BOOTLOADER_ALLOW_CACHE 这些选项，则不会进行写保护，
                以便稍后有机会将芯片转入发布模式。

                具有相同写保护位的 eFuses 列表：
                ESP32: MAC, MAC_CRC, DISABLE_APP_CPU, DISABLE_BT, DIS_CACHE, VOL_LEVEL_HP_INV.

                ESP32-C3: DIS_ICACHE, DIS_USB_JTAG, DIS_DOWNLOAD_ICACHE, DIS_USB_SERIAL_JTAG,
                DIS_FORCE_DOWNLOAD, DIS_TWAI, JTAG_SEL_ENABLE, DIS_PAD_JTAG, DIS_DOWNLOAD_MANUAL_ENCRYPT.

                ESP32-C6: SWAP_UART_SDIO_EN, DIS_ICACHE, DIS_USB_JTAG, DIS_DOWNLOAD_ICACHE,
                DIS_USB_SERIAL_JTAG, DIS_FORCE_DOWNLOAD, DIS_TWAI, JTAG_SEL_ENABLE,
                DIS_PAD_JTAG, DIS_DOWNLOAD_MANUAL_ENCRYPT.

                ESP32-H2: DIS_ICACHE, DIS_USB_JTAG, POWERGLITCH_EN, DIS_FORCE_DOWNLOAD, SPI_DOWNLOAD_MSPI_DIS,
                DIS_TWAI, JTAG_SEL_ENABLE, DIS_PAD_JTAG, DIS_DOWNLOAD_MANUAL_ENCRYPT.

                ESP32-S2: DIS_ICACHE, DIS_DCACHE, DIS_DOWNLOAD_ICACHE, DIS_DOWNLOAD_DCACHE,
                DIS_FORCE_DOWNLOAD, DIS_USB, DIS_TWAI, DIS_BOOT_REMAP, SOFT_DIS_JTAG,
                HARD_DIS_JTAG, DIS_DOWNLOAD_MANUAL_ENCRYPT.

                ESP32-S3: DIS_ICACHE, DIS_DCACHE, DIS_DOWNLOAD_ICACHE, DIS_DOWNLOAD_DCACHE,
                DIS_FORCE_DOWNLOAD, DIS_USB_OTG, DIS_TWAI, DIS_APP_CPU, DIS_PAD_JTAG,
                DIS_DOWNLOAD_MANUAL_ENCRYPT, DIS_USB_JTAG, DIS_USB_SERIAL_JTAG, STRAP_JTAG_SEL, USB_PHY_SEL.
    endmenu  # Potentially Insecure

    config SECURE_FLASH_ENCRYPT_ONLY_IMAGE_LEN_IN_APP_PART
        bool "仅加密 APP 分区中存在的应用程序镜像"
        depends on SECURE_FLASH_ENC_ENABLED && !SECURE_FLASH_REQUIRE_ALREADY_ENABLED
        default y
        help
            如果设置（默认），优化 APP 类型分区的加密时间，
            只加密分区中存在的应用程序镜像，而不是整个分区。
            用于加密的镜像长度是从镜像元数据中派生的，其中
            包括应用程序镜像的大小、校验和、哈希，以及在启用安全启动时的签名扇区。

            如果未设置，APP 类型的整个分区都将被加密，
            这会增加加密时间，但如果固件镜像后附加了任何自定义数据，可能会有用。

    config SECURE_FLASH_CHECK_ENC_EN_IN_APP
        bool "在应用程序启动时检查闪存加密是否启用"
        depends on SECURE_FLASH_ENC_ENABLED
        default y
        help
            如果设置（默认），在应用程序启动代码中，
            会检查闪存加密 eFuse 位是否打开
            （因为引导加载程序应该已经设置了它）。
            应用程序要求此位打开才能继续工作，否则中止。

            如果未设置，应用程序不关心闪存加密 eFuse 位是否设置。

    config SECURE_ROM_DL_MODE_ENABLED
        bool
        default y if SOC_SUPPORTS_SECURE_DL_MODE && !SECURE_FLASH_ENCRYPTION_MODE_DEVELOPMENT

    choice SECURE_UART_ROM_DL_MODE
        bool "UART ROM 下载模式"
        default SECURE_ENABLE_SECURE_ROM_DL_MODE if SECURE_ROM_DL_MODE_ENABLED # NOERROR
        default SECURE_INSECURE_ALLOW_DL_MODE
        depends on SECURE_BOOT_V2_ENABLED || SECURE_FLASH_ENC_ENABLED
        depends on !(IDF_TARGET_ESP32 && ESP32_REV_MIN_FULL < 300)

        config SECURE_DISABLE_ROM_DL_MODE
            bool "UART ROM 下载模式（永久禁用（推荐））"
            help
                如果设置，在启动期间，应用程序将烧录一个 eFuse 位以永久禁用 UART ROM
                下载模式。这将阻止将来使用 esptool.py、espefuse.py 和类似工具。

                一旦禁用，如果 SoC 以设置为 ROM 下载模式的绑定引脚启动，
                则会打印错误信息。

                建议在任何启用了闪存加密和/或安全启动且不需要访问下载模式的生产应用程序中启用此选项。

                也可以通过在运行时调用 esp_efuse_disable_rom_download_mode() 来永久禁用下载模式。

        config SECURE_ENABLE_SECURE_ROM_DL_MODE
            bool "UART ROM 下载模式（永久切换到安全模式（推荐））"
            depends on SOC_SUPPORTS_SECURE_DL_MODE
            select ESPTOOLPY_NO_STUB
            help
                如果设置，在启动期间，应用程序将烧录一个 eFuse 位以永久将 UART ROM
                下载模式切换到单独的安全下载模式。此选项仅在下载模式尚未被 eFuse 禁用时才能工作。

                安全下载模式限制了下载模式功能的使用，仅允许更新 SPI 配置、
                更改波特率、基本闪存写入和返回当前启用的安全功能摘要的命令（`get_security_info`）。

                安全下载模式与 esptool.py 闪存器存根功能、espefuse.py、读/写内存或寄存器、
                加密下载或任何其他与不支持的下载模式命令交互的功能不兼容。

                应在启用了闪存加密和/或安全启动的任何应用程序中启用安全下载模式。
                禁用此选项不会立即取消安全功能的好处，但它会增加攻击者
                尝试通过成功的物理攻击绕过它们的潜在"攻击面"。

                也可以通过调用 esp_efuse_enable_rom_secure_download_mode() 在运行时启用安全下载模式

                注意：安全下载模式不适用于 ESP32（包括直到 ECO3 的修订版）。

        config SECURE_INSECURE_ALLOW_DL_MODE
            bool "UART ROM 下载模式（启用（不推荐））"
            help
                这是一个潜在的不安全选项。
                启用此选项将允许完整的 UART 下载模式保持启用状态。
                此选项不应在生产用例中启用。
    endchoice
endmenu  # Security features
