menu "硬件设置"

    menu "芯片版本"
        # Insert chip-specific HW config
        orsource "./port/$IDF_TARGET/Kconfig.hw_support"

        config ESP_REV_NEW_CHIP_TEST
            bool "内部测试模式"
            depends on IDF_CI_BUILD
            default n
            help
                对于内部芯片测试，少量新版本芯片没有更新eFuse中的版本字段，
                您可以启用此选项以强制软件根据menuconfig中选择的版本识别芯片版本。
    endmenu

    menu "MAC配置"
        config ESP_MAC_ADDR_UNIVERSE_WIFI_STA
            bool

        config ESP_MAC_ADDR_UNIVERSE_WIFI_AP
            bool

        config ESP_MAC_ADDR_UNIVERSE_BT
            bool

        config ESP_MAC_ADDR_UNIVERSE_ETH
            bool

        config ESP_MAC_ADDR_UNIVERSE_IEEE802154
            bool

        config ESP_MAC_UNIVERSAL_MAC_ADDRESSES_ONE
            bool

        config ESP_MAC_UNIVERSAL_MAC_ADDRESSES_TWO
            bool

        config ESP_MAC_UNIVERSAL_MAC_ADDRESSES_FOUR
            bool

        config ESP_MAC_UNIVERSAL_MAC_ADDRESSES
            int
            default 1 if ESP_MAC_UNIVERSAL_MAC_ADDRESSES_ONE
            default 2 if ESP_MAC_UNIVERSAL_MAC_ADDRESSES_TWO
            default 4 if ESP_MAC_UNIVERSAL_MAC_ADDRESSES_FOUR

            # Insert chip-specific MAC config
        orsource "./port/$IDF_TARGET/Kconfig.mac"

        config ESP_MAC_IGNORE_MAC_CRC_ERROR
            bool "忽略MAC CRC错误（不推荐）"
            depends on IDF_TARGET_ESP32
            default n
            help
                如果您遇到无效的MAC CRC（ESP_ERR_INVALID_CRC）问题，
                但仍然想使用这个芯片，您可以启用此选项来绕过这样的错误。
                这适用于MAC_FACTORY和CUSTOM_MAC efuses。

        config ESP_MAC_USE_CUSTOM_MAC_AS_BASE_MAC
            bool "启用使用自定义MAC作为基础MAC"
            default n
            help
                当启用此配置时，用户可以调用`esp_read_mac`来获取所需类型的MAC，
                使用自定义MAC作为基础MAC。
    endmenu

    menu "睡眠配置"
        # This is here since this option affect behavior of esp_light_sleep_start
        # regardless of power management configuration.
        config ESP_SLEEP_POWER_DOWN_FLASH
            bool "在没有SPIRAM时，轻度睡眠时关闭闪存电源"
            depends on !SPIRAM
            default n
            help
                如果启用，芯片将尝试在esp_light_sleep_start()过程中关闭闪存电源，
                这会导致芯片唤醒时花费更多时间。只有在未配置SPIRAM时才能启用。

                此选项将在严格但相对安全的条件下关闭闪存电源。此外，
                还可以通过使用esp_sleep_pd_config()将ESP_PD_DOMAIN_VDDSDIO
                设置为ESP_PD_OPTION_OFF来在宽松条件下关闭闪存电源。
                应注意，关闭闪存电源存在风险，您可以参考
                `ESP-IDF编程指南/API参考/系统API/睡眠模式/闪存电源关闭`以获取更多详细信息。

        config ESP_SLEEP_FLASH_LEAKAGE_WORKAROUND
            bool "在轻度睡眠时拉高Flash CS引脚"
            depends on !APP_BUILD_TYPE_PURE_RAM_APP && !ESP_SLEEP_POWER_DOWN_FLASH
            default y
            help
                默认情况下，所有IO在睡眠期间将被设置为隔离（浮空）状态。
                由于SPI Flash的电源在轻度睡眠期间不会断开，如果其CS引脚在浮空状态下被识别为
                低电平（选中状态），将会有大量电流泄漏，并且Flash中的数据可能会被其他SPI引脚
                上的随机信号破坏。
                选择此选项将在睡眠期间将Flash的CS引脚设置为上拉状态，但这将增加约10 uA的
                睡眠电流。
                如果您正在开发esp32xx模块，您必须选择此选项，但如果您正在开发芯片，
                您也可以在外部电路中拉高SPI Flash的CS引脚，以节省睡眠期间内部上拉造成的
                功耗。
                （！！！如果您没有外部SPI Flash CS引脚上拉，请不要取消选择此选项。）

        config ESP_SLEEP_PSRAM_LEAKAGE_WORKAROUND
            bool "在轻度睡眠时拉高PSRAM CS引脚"
            depends on SPIRAM
            default y
            help
                默认情况下，所有IO在睡眠期间将被设置为隔离（浮空）状态。
                由于PSRAM的电源在轻度睡眠期间不会断开，如果其CS引脚在浮空状态下被识别为
                低电平（选中状态），将会有大量电流泄漏，并且PSRAM中的数据可能会被其他SPI引脚
                上的随机信号破坏。
                选择此选项将在睡眠期间将PSRAM的CS引脚设置为上拉状态，但这将增加约10 uA的
                睡眠电流。
                如果您正在开发esp32xx模块，您必须选择此选项，但如果您正在开发芯片，
                您也可以在外部电路中拉高PSRAM的CS引脚，以节省睡眠期间内部上拉造成的
                功耗。
                （！！！如果您没有外部PSRAM CS引脚上拉，请不要取消选择此选项。）

        config ESP_SLEEP_MSPI_NEED_ALL_IO_PU
            bool "在轻度睡眠时拉高所有SPI引脚"
            depends on !ESP_SLEEP_POWER_DOWN_FLASH \
                && (ESP_SLEEP_PSRAM_LEAKAGE_WORKAROUND || ESP_SLEEP_FLASH_LEAKAGE_WORKAROUND)
            default y if IDF_TARGET_ESP32C2 || IDF_TARGET_ESP32S3
            help
                为了减少泄漏电流，某些类型的SPI Flash/RAM在轻度睡眠期间只需要拉高CS引脚。
                但也有一些类型的SPI Flash/RAM需要拉高所有引脚。这取决于所使用的SPI Flash/RAM芯片。

        config ESP_SLEEP_RTC_BUS_ISO_WORKAROUND
            bool
            default y if IDF_TARGET_ESP32 || IDF_TARGET_ESP32S2 || IDF_TARGET_ESP32S3

        config ESP_SLEEP_GPIO_RESET_WORKAROUND
            bool "轻度睡眠GPIO复位解决方案"
            default y if IDF_TARGET_ESP32C2 || IDF_TARGET_ESP32C3 || IDF_TARGET_ESP32S3 || \
                IDF_TARGET_ESP32C6 || IDF_TARGET_ESP32H2
            select PM_SLP_DISABLE_GPIO if FREERTOS_USE_TICKLESS_IDLE
            help
                esp32c2、esp32c3、esp32s3、esp32c6和esp32h2在特定条件下，
                如果GPIO在轻度睡眠期间接收到小的静电脉冲，将在唤醒时复位

                - GPIO需要配置为仅输入模式
                - 引脚接收到小的静电脉冲，当脉冲电压高于6 V时会发生复位

                对于设置为仅输入模式的GPIO，将其保持开放/浮空不是一个好的做法，
                硬件设计需要用确定的供电或接地电压来控制它是必要的。

                此选项为这个问题提供了软件解决方案。配置为在睡眠状态下隔离所有GPIO引脚。

        config ESP_SLEEP_WAIT_FLASH_READY_EXTRA_DELAY
            int "闪存电源关闭睡眠唤醒后等待闪存就绪的额外延迟（以微秒为单位）"
            default 2000 if IDF_TARGET_ESP32 || IDF_TARGET_ESP32S3
            default 0
            range 0 5000
            help
                当芯片退出睡眠时，CPU和闪存芯片同时上电。
                CPU将首先运行ROM代码（深度睡眠）或RAM代码（轻度睡眠），然后从闪存加载或执行代码。

                一些闪存芯片需要在上电和第一次读取操作之间有足够的时间。
                默认情况下，没有任何额外延迟，这个时间大约是900us，尽管某些闪存芯片类型需要更多时间。

                （！！！请根据您项目中使用的SPI闪存的数据表调整此值。）
                在闪存数据表中，定义闪存上电后就绪时间的参数（从Vcc(min)到CS激活的最小时间）
                通常在电气特性章节中命名为tVSL，这里的配置值应该是：
                ESP_SLEEP_WAIT_FLASH_READY_EXTRA_DELAY = tVSL - 900

                对于esp32和esp32s3，默认额外延迟设置为2000us。在优化需要它的应用程序的启动时间时，
                可以减少这个值。

                如果您在esp32的深度睡眠复位后看到控制台打印"flash read err, 1000"消息，
                或在轻度睡眠唤醒后触发RTC_WDT/LP_WDT，请尝试增加此值。
                （对于esp32，这个延迟将在深度睡眠和轻度睡眠唤醒流程中执行。
                对于esp32之后的芯片，这个延迟将只在轻度睡眠流程中执行，
                在深度睡眠唤醒流程中，由ROM中的EFUSE_FLASH_TPUW控制的延迟将被执行。）

        config ESP_SLEEP_CACHE_SAFE_ASSERTION
            bool "在睡眠过程中检查睡眠唤醒代码的缓存安全性"
            default n
            select ESP_PANIC_HANDLER_IRAM
            help
                启用它将在轻度睡眠唤醒后闪存电源就绪之前检查代码的缓存安全性，
                并检查PM_SLP_IRAM_OPT相关代码的缓存安全性。此选项仅用于代码质量检查。
                启用它将增加进入和退出睡眠的时间开销。不建议在发布版本中启用它。

        config ESP_SLEEP_DEBUG
            bool "esp睡眠调试"
            default n
            help
                启用esp睡眠调试。

        config ESP_SLEEP_GPIO_ENABLE_INTERNAL_RESISTORS
            bool "允许为深度睡眠唤醒IO启用内部上拉/下拉电阻"
            default y
            help
                当在深度睡眠期间使用rtc gpio唤醒源而没有外部上拉/下拉电阻时，
                您可能想要使用内部电阻。

        config ESP_SLEEP_EVENT_CALLBACKS
            bool "启用睡眠事件回调注册"
            depends on FREERTOS_USE_TICKLESS_IDLE
            default n
            help
                如果启用，它允许用户注册睡眠事件回调。它主要为内部开发人员设计，
                客户可以使用PM_LIGHT_SLEEP_CALLBACKS作为替代方案。

                注意：这些回调是从IDLE任务上下文执行的，因此您不能在回调中有任何阻塞调用。

                注意：启用这些回调可能会根据回调中花费的时间改变睡眠持续时间计算，
                因此强烈建议保持它们尽可能短。
    endmenu

    menu "RTC时钟配置"
        orsource "./port/$IDF_TARGET/Kconfig.rtc"
    endmenu

    menu "外设控制"
        config PERIPH_CTRL_FUNC_IN_IRAM
            bool "将外设控制函数放入IRAM"
            default n
            help
                将外设控制函数（例如periph_module_reset）放入IRAM，
                以便这些函数可以在IRAM中安全使用，并能够在其他IRAM中断上下文中调用。
    endmenu

    menu "ETM配置"
        depends on SOC_ETM_SUPPORTED
        config ETM_ENABLE_DEBUG_LOG
            bool "启用调试日志"
            default n
            help
                是否为ETM核心驱动启用调试日志消息。
                注意，此选项仅控制ETM相关驱动的日志，不会影响其他驱动。
    endmenu # ETM Configuration

    rsource "./dma/Kconfig.dma"

    menu "主XTAL配置"
        # TODO: IDF-8943
        choice XTAL_FREQ_SEL
            prompt "主XTAL频率"
            default XTAL_FREQ_48 if SOC_XTAL_SUPPORT_48M
            default XTAL_FREQ_40 if (SOC_XTAL_SUPPORT_40M && !SOC_XTAL_SUPPORT_48M)
            help
                此选项选择用于驱动ESP目标的XTAL（晶体）时钟的工作频率。
                所选值必须反映给定硬件的频率。

                注意：XTAL_FREQ_AUTO选项允许ESP目标自动估计XTAL时钟的工作频率。
                然而，此功能仅在ESP32上支持。ESP32使用内部8MHz作为参考进行估计。
                由于内部振荡器的频率依赖于温度，在高环境温度下运行的应用程序或
                使用高温合格芯片和模块时，不建议使用XTAL_FREQ_AUTO。

            config XTAL_FREQ_24
                depends on SOC_XTAL_SUPPORT_24M
                bool "24 MHz"
            config XTAL_FREQ_26
                depends on SOC_XTAL_SUPPORT_26M
                bool "26 MHz"
            config XTAL_FREQ_32
                depends on SOC_XTAL_SUPPORT_32M
                bool "32 MHz"
            config XTAL_FREQ_40
                depends on SOC_XTAL_SUPPORT_40M
                bool "40 MHz"
            config XTAL_FREQ_48
                depends on SOC_XTAL_SUPPORT_48M
                bool "48 MHz"
            config XTAL_FREQ_AUTO
                depends on SOC_XTAL_SUPPORT_AUTO_DETECT
                bool "自动检测"
        endchoice

        # soc_xtal_freq_t enum in soc/clk_tree_defs.h lists the XTAL frequencies can be supported
        # SOC_XTAL_SUPPORT_XXX in soc_caps.h lists the XTAL frequencies already supported
        config XTAL_FREQ
            int "XTAL频率值"
            default 24 if XTAL_FREQ_24
            default 26 if XTAL_FREQ_26
            default 32 if XTAL_FREQ_32
            default 40 if XTAL_FREQ_40
            default 48 if XTAL_FREQ_48
            default 0  if XTAL_FREQ_AUTO
    endmenu

    menu "加密DPA保护"
        depends on SOC_CRYPTO_DPA_PROTECTION_SUPPORTED
        config ESP_CRYPTO_DPA_PROTECTION_AT_STARTUP
            bool "在启动时启用加密DPA保护"
            default y
            help
                此配置控制加密外设的DPA（差分功率分析）保护旋钮。
                DPA保护动态调整加密外设的时钟频率。DPA保护有助于
                使对加密外设进行SCA攻击变得困难。然而，根据设置的
                安全级别，也会有相应的性能影响。更多详情请参阅TRM。

        choice ESP_CRYPTO_DPA_PROTECTION_LEVEL
            prompt "DPA保护级别"
            depends on ESP_CRYPTO_DPA_PROTECTION_AT_STARTUP
            default ESP_CRYPTO_DPA_PROTECTION_LEVEL_LOW
            help
                配置DPA保护安全级别

            config ESP_CRYPTO_DPA_PROTECTION_LEVEL_LOW
                bool "低安全级别"

            config ESP_CRYPTO_DPA_PROTECTION_LEVEL_MEDIUM
                bool "中等安全级别"

            config ESP_CRYPTO_DPA_PROTECTION_LEVEL_HIGH
                bool "高安全级别"
        endchoice

        config ESP_CRYPTO_DPA_PROTECTION_LEVEL
            int "DPA保护级别值"
            default 1 if ESP_CRYPTO_DPA_PROTECTION_LEVEL_LOW
            default 2 if ESP_CRYPTO_DPA_PROTECTION_LEVEL_MEDIUM
            default 3 if ESP_CRYPTO_DPA_PROTECTION_LEVEL_HIGH

    endmenu

    orsource "./port/$IDF_TARGET/Kconfig.dcdc"

    orsource "./port/$IDF_TARGET/Kconfig.ldo"

    # Invisible bringup bypass options for esp_hw_support component
    config ESP_BRINGUP_BYPASS_CPU_CLK_SETTING
        bool "绕过CPU时钟设置"
        # TODO: [ESP32C5] IDF-8642 IDF_TARGET_ESP32C5 is added because clock
        # is required when bringup on C5 beta3, remove it when clock tree is
        # supported
        default y if !SOC_CLK_TREE_SUPPORTED && !IDF_TARGET_ESP32C5
        default n
        help
            此选项仅用于新芯片的引导，当时钟支持尚未完成时。
            因此，使用此选项时，我们在FPGA上使用xtal作为时钟源。

    config ESP_BRINGUP_BYPASS_RANDOM_SETTING
        bool "绕过随机设置"
        default y if !SOC_RNG_SUPPORTED
        default n
        help
            此选项仅用于新芯片的引导，当RNG尚未完成时。
            因此，使用此选项时，我们使用0x5A填充随机缓冲区。

    config ESP_SPI_BUS_LOCK_ISR_FUNCS_IN_IRAM
        bool "将SPI总线锁ISR函数放入IRAM"
        default n

    config ESP_SPI_BUS_LOCK_FUNCS_IN_IRAM
        bool "将SPI总线锁函数放入IRAM"
        default n
endmenu
