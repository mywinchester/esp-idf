menu "Newlib"

    choice NEWLIB_STDOUT_LINE_ENDING
        prompt "UART输出的行结束符"
        default NEWLIB_STDOUT_LINE_ENDING_CRLF
        help
            此选项允许配置当stdout上出现换行符（'\n'，LF）时发送到UART的所需行结束符。
            有三种可能的选项：

            CRLF：每当遇到LF时，在其前面加上CR

            LF：不进行修改，按原样发送stdout

            CR：将每次出现的LF替换为CR

            此选项不影响UART驱动程序（drivers/uart.h）的行为。

        config NEWLIB_STDOUT_LINE_ENDING_CRLF
            bool "CRLF"
        config NEWLIB_STDOUT_LINE_ENDING_LF
            bool "LF"
        config NEWLIB_STDOUT_LINE_ENDING_CR
            bool "CR"
    endchoice

    choice NEWLIB_STDIN_LINE_ENDING
        prompt "UART输入的行结束符"
        default NEWLIB_STDIN_LINE_ENDING_CR
        help
            此选项允许配置在UART上产生stdin换行符（'\n'，LF）的输入序列。
            有三种可能的选项：

            CRLF：CRLF被转换为LF

            LF：不进行修改，输入按原样发送到stdin

            CR：将每次出现的CR替换为LF

            此选项不影响UART驱动程序（drivers/uart.h）的行为。

        config NEWLIB_STDIN_LINE_ENDING_CRLF
            bool "CRLF"
        config NEWLIB_STDIN_LINE_ENDING_LF
            bool "LF"
        config NEWLIB_STDIN_LINE_ENDING_CR
            bool "CR"
    endchoice

    config NEWLIB_NANO_FORMAT
        bool "为printf/scanf系列函数启用'nano'格式化选项"
        default y if IDF_TARGET_ESP32C2
        help
            在大多数芯片中，ROM包含newlib C库的部分内容，包括printf/scanf系列函数。
            这些函数已经使用所谓的"nano"格式化选项进行编译。此选项不支持64位整数格式和C99特性，
            如位置参数。

            有关"nano"格式化选项的更多详细信息，请参阅newlib自述文件，
            搜索'--enable-newlib-nano-formatted-io'：
            https://sourceware.org/git/?p=newlib-cygwin.git;a=blob_plain;f=newlib/README;hb=HEAD

            如果启用此选项，并且ROM包含来自newlib-nano的函数，构建系统将使用ROM中可用的函数，
            从而减小应用程序二进制文件的大小。ROM中可用的函数运行速度比从flash运行的函数更快。
            当禁用flash指令缓存时，ROM中可用的函数也可以运行。

            某些芯片（例如ESP32-C6）在ROM中包含printf/scanf的完整格式化版本，而不是nano版本，
            在这种情况下，使用newlib nano实际上可能会增加二进制文件的大小。可以从ROM功能中
            看到哪些函数存在于ROM中：ESP_ROM_HAS_NEWLIB_NANO_FORMAT和ESP_ROM_HAS_NEWLIB_NORMAL_FORMAT。

            如果您需要64位整数格式支持或C99特性，请保持此选项禁用。

    choice NEWLIB_TIME_SYSCALL
        prompt "用于gettimeofday函数的定时器"
        default NEWLIB_TIME_SYSCALL_USE_RTC_HRT
        help
            此设置定义了在C库中实现'gettimeofday'和'time'函数所使用的硬件定时器。

            - 如果同时使用高分辨率（除ESP32外的所有目标使用systimer）和RTC定时器，
              则在深度睡眠中时间保持将继续。时间将以1微秒的分辨率报告。
              这是默认选项，也是推荐选项。
            - 如果仅使用高分辨率定时器（systimer），gettimeofday将提供微秒分辨率的时间。
              进入深度睡眠模式时，时间将不会保留。
            - 如果仅使用RTC定时器，时间保持将在深度睡眠中继续，但时间将以6.(6)微秒的
              分辨率测量。此外，gettimeofday函数本身可能需要更长时间运行。
            - 如果不使用任何定时器，gettimeofday和time函数将返回-1并将errno设置为ENOSYS；
              它们被定义为弱符号，因此可以被覆盖。
              如果您想自定义gettimeofday()和其他时间函数，请选择此选项，
              并参考'time.c'源文件以获取这些函数的确切原型。

            - 当使用RTC进行计时时，两个RTC_STORE寄存器用于在深度睡眠模式下保持时间。

        config NEWLIB_TIME_SYSCALL_USE_RTC_HRT
            bool "RTC和高分辨率定时器"
            select ESP_TIME_FUNCS_USE_RTC_TIMER
            select ESP_TIME_FUNCS_USE_ESP_TIMER
        config NEWLIB_TIME_SYSCALL_USE_RTC
            bool "RTC"
            select ESP_TIME_FUNCS_USE_RTC_TIMER
        config NEWLIB_TIME_SYSCALL_USE_HRT
            bool "高分辨率定时器"
            select ESP_TIME_FUNCS_USE_ESP_TIMER
        config NEWLIB_TIME_SYSCALL_USE_NONE
            bool "无"
            select ESP_TIME_FUNCS_USE_NONE
    endchoice

endmenu # Newlib

config STDATOMIC_S32C1I_SPIRAM_WORKAROUND
    bool
    default SPIRAM && (IDF_TARGET_ESP32 || IDF_TARGET_ESP32S3) && !IDF_TOOLCHAIN_CLANG # TODO IDF-9032
